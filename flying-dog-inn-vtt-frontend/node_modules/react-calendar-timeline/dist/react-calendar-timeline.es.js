import { jsxs as Xe, jsx as H } from "react/jsx-runtime";
import se, { useContext as Ti, Component as xe, PureComponent as bs, createElement as ys } from "react";
import './styles.css';/* empty css                            */
var Fe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ze(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var Rt = { exports: {} };
Rt.exports;
(function(a, i) {
  (function(s, u) {
    a.exports = u();
  })(Fe, function() {
    function s(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(t);
        e && (n = n.filter(function(o) {
          return Object.getOwnPropertyDescriptor(t, o).enumerable;
        })), r.push.apply(r, n);
      }
      return r;
    }
    function u(t) {
      for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? s(Object(r), !0).forEach(function(n) {
          x(t, n, r[n]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : s(Object(r)).forEach(function(n) {
          Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
        });
      }
      return t;
    }
    function f(t) {
      return f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e;
      } : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      }, f(t);
    }
    function v(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
    }
    function m(t, e) {
      for (var r = 0; r < e.length; r++) {
        var n = e[r];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, _(n.key), n);
      }
    }
    function y(t, e, r) {
      return e && m(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t;
    }
    function x(t, e, r) {
      return (e = _(e)) in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t;
    }
    function O(t, e) {
      if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && P(t, e);
    }
    function k(t) {
      return k = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      }, k(t);
    }
    function P(t, e) {
      return P = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
        return r.__proto__ = n, r;
      }, P(t, e);
    }
    function T(t) {
      if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t;
    }
    function C(t) {
      var e = function() {
        if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
        if (typeof Proxy == "function") return !0;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), !0;
        } catch {
          return !1;
        }
      }();
      return function() {
        var r, n = k(t);
        if (e) {
          var o = k(this).constructor;
          r = Reflect.construct(n, arguments, o);
        } else r = n.apply(this, arguments);
        return function(l, c) {
          if (c && (typeof c == "object" || typeof c == "function")) return c;
          if (c !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
          return T(l);
        }(this, r);
      };
    }
    function M() {
      return M = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(t, e, r) {
        var n = function(l, c) {
          for (; !Object.prototype.hasOwnProperty.call(l, c) && (l = k(l)) !== null; ) ;
          return l;
        }(t, e);
        if (n) {
          var o = Object.getOwnPropertyDescriptor(n, e);
          return o.get ? o.get.call(arguments.length < 3 ? t : r) : o.value;
        }
      }, M.apply(this, arguments);
    }
    function _(t) {
      var e = function(r, n) {
        if (typeof r != "object" || r === null) return r;
        var o = r[Symbol.toPrimitive];
        if (o !== void 0) {
          var l = o.call(r, n);
          if (typeof l != "object") return l;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return String(r);
      }(t, "string");
      return typeof e == "symbol" ? e : e + "";
    }
    var z = function(t) {
      return !(!t || !t.Window) && t instanceof t.Window;
    }, X = void 0, Y = void 0;
    function ee(t) {
      X = t;
      var e = t.document.createTextNode("");
      e.ownerDocument !== t.document && typeof t.wrap == "function" && t.wrap(e) === e && (t = t.wrap(t)), Y = t;
    }
    function te(t) {
      return z(t) ? t : (t.ownerDocument || t).defaultView || Y.window;
    }
    typeof window < "u" && window && ee(window);
    var ne = function(t) {
      return !!t && f(t) === "object";
    }, ue = function(t) {
      return typeof t == "function";
    }, S = { window: function(t) {
      return t === Y || z(t);
    }, docFrag: function(t) {
      return ne(t) && t.nodeType === 11;
    }, object: ne, func: ue, number: function(t) {
      return typeof t == "number";
    }, bool: function(t) {
      return typeof t == "boolean";
    }, string: function(t) {
      return typeof t == "string";
    }, element: function(t) {
      if (!t || f(t) !== "object") return !1;
      var e = te(t) || Y;
      return /object|function/.test(typeof Element > "u" ? "undefined" : f(Element)) ? t instanceof Element || t instanceof e.Element : t.nodeType === 1 && typeof t.nodeName == "string";
    }, plainObject: function(t) {
      return ne(t) && !!t.constructor && /function Object\b/.test(t.constructor.toString());
    }, array: function(t) {
      return ne(t) && t.length !== void 0 && ue(t.splice);
    } };
    function be(t) {
      var e = t.interaction;
      if (e.prepared.name === "drag") {
        var r = e.prepared.axis;
        r === "x" ? (e.coords.cur.page.y = e.coords.start.page.y, e.coords.cur.client.y = e.coords.start.client.y, e.coords.velocity.client.y = 0, e.coords.velocity.page.y = 0) : r === "y" && (e.coords.cur.page.x = e.coords.start.page.x, e.coords.cur.client.x = e.coords.start.client.x, e.coords.velocity.client.x = 0, e.coords.velocity.page.x = 0);
      }
    }
    function we(t) {
      var e = t.iEvent, r = t.interaction;
      if (r.prepared.name === "drag") {
        var n = r.prepared.axis;
        if (n === "x" || n === "y") {
          var o = n === "x" ? "y" : "x";
          e.page[o] = r.coords.start.page[o], e.client[o] = r.coords.start.client[o], e.delta[o] = 0;
        }
      }
    }
    var ce = { id: "actions/drag", install: function(t) {
      var e = t.actions, r = t.Interactable, n = t.defaults;
      r.prototype.draggable = ce.draggable, e.map.drag = ce, e.methodDict.drag = "draggable", n.actions.drag = ce.defaults;
    }, listeners: { "interactions:before-action-move": be, "interactions:action-resume": be, "interactions:action-move": we, "auto-start:check": function(t) {
      var e = t.interaction, r = t.interactable, n = t.buttons, o = r.options.drag;
      if (o && o.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || n & r.options.drag.mouseButtons)) return t.action = { name: "drag", axis: o.lockAxis === "start" ? o.startAxis : o.lockAxis }, !1;
    } }, draggable: function(t) {
      return S.object(t) ? (this.options.drag.enabled = t.enabled !== !1, this.setPerAction("drag", t), this.setOnEvents("drag", t), /^(xy|x|y|start)$/.test(t.lockAxis) && (this.options.drag.lockAxis = t.lockAxis), /^(xy|x|y)$/.test(t.startAxis) && (this.options.drag.startAxis = t.startAxis), this) : S.bool(t) ? (this.options.drag.enabled = t, this) : this.options.drag;
    }, beforeMove: be, move: we, defaults: { startAxis: "xy", lockAxis: "xy" }, getCursor: function() {
      return "move";
    }, filterEventType: function(t) {
      return t.search("drag") === 0;
    } }, re = ce, de = { init: function(t) {
      var e = t;
      de.document = e.document, de.DocumentFragment = e.DocumentFragment || Ce, de.SVGElement = e.SVGElement || Ce, de.SVGSVGElement = e.SVGSVGElement || Ce, de.SVGElementInstance = e.SVGElementInstance || Ce, de.Element = e.Element || Ce, de.HTMLElement = e.HTMLElement || de.Element, de.Event = e.Event, de.Touch = e.Touch || Ce, de.PointerEvent = e.PointerEvent || e.MSPointerEvent;
    }, document: null, DocumentFragment: null, SVGElement: null, SVGSVGElement: null, SVGElementInstance: null, Element: null, HTMLElement: null, Event: null, Touch: null, PointerEvent: null };
    function Ce() {
    }
    var W = de, R = { init: function(t) {
      var e = W.Element, r = t.navigator || {};
      R.supportsTouch = "ontouchstart" in t || S.func(t.DocumentTouch) && W.document instanceof t.DocumentTouch, R.supportsPointerEvent = r.pointerEnabled !== !1 && !!W.PointerEvent, R.isIOS = /iP(hone|od|ad)/.test(r.platform), R.isIOS7 = /iP(hone|od|ad)/.test(r.platform) && /OS 7[^\d]/.test(r.appVersion), R.isIe9 = /MSIE 9/.test(r.userAgent), R.isOperaMobile = r.appName === "Opera" && R.supportsTouch && /Presto/.test(r.userAgent), R.prefixedMatchesSelector = "matches" in e.prototype ? "matches" : "webkitMatchesSelector" in e.prototype ? "webkitMatchesSelector" : "mozMatchesSelector" in e.prototype ? "mozMatchesSelector" : "oMatchesSelector" in e.prototype ? "oMatchesSelector" : "msMatchesSelector", R.pEventTypes = R.supportsPointerEvent ? W.PointerEvent === t.MSPointerEvent ? { up: "MSPointerUp", down: "MSPointerDown", over: "mouseover", out: "mouseout", move: "MSPointerMove", cancel: "MSPointerCancel" } : { up: "pointerup", down: "pointerdown", over: "pointerover", out: "pointerout", move: "pointermove", cancel: "pointercancel" } : null, R.wheelEvent = W.document && "onmousewheel" in W.document ? "mousewheel" : "wheel";
    }, supportsTouch: null, supportsPointerEvent: null, isIOS7: null, isIOS: null, isIe9: null, isOperaMobile: null, prefixedMatchesSelector: null, pEventTypes: null, wheelEvent: null }, $ = R;
    function U(t, e) {
      if (t.contains) return t.contains(e);
      for (; e; ) {
        if (e === t) return !0;
        e = e.parentNode;
      }
      return !1;
    }
    function A(t, e) {
      for (; S.element(t); ) {
        if (K(t, e)) return t;
        t = G(t);
      }
      return null;
    }
    function G(t) {
      var e = t.parentNode;
      if (S.docFrag(e)) {
        for (; (e = e.host) && S.docFrag(e); ) ;
        return e;
      }
      return e;
    }
    function K(t, e) {
      return Y !== X && (e = e.replace(/\/deep\//g, " ")), t[$.prefixedMatchesSelector](e);
    }
    var ie = function(t) {
      return t.parentNode || t.host;
    };
    function ae(t, e) {
      for (var r, n = [], o = t; (r = ie(o)) && o !== e && r !== o.ownerDocument; ) n.unshift(o), o = r;
      return n;
    }
    function pe(t, e, r) {
      for (; S.element(t); ) {
        if (K(t, e)) return !0;
        if ((t = G(t)) === r) return K(t, e);
      }
      return !1;
    }
    function he(t) {
      return t.correspondingUseElement || t;
    }
    function ve(t) {
      var e = t instanceof W.SVGElement ? t.getBoundingClientRect() : t.getClientRects()[0];
      return e && { left: e.left, right: e.right, top: e.top, bottom: e.bottom, width: e.width || e.right - e.left, height: e.height || e.bottom - e.top };
    }
    function Oe(t) {
      var e, r = ve(t);
      if (!$.isIOS7 && r) {
        var n = { x: (e = (e = te(t)) || Y).scrollX || e.document.documentElement.scrollLeft, y: e.scrollY || e.document.documentElement.scrollTop };
        r.left += n.x, r.right += n.x, r.top += n.y, r.bottom += n.y;
      }
      return r;
    }
    function _e(t) {
      for (var e = []; t; ) e.push(t), t = G(t);
      return e;
    }
    function ke(t) {
      return !!S.string(t) && (W.document.querySelector(t), !0);
    }
    function F(t, e) {
      for (var r in e) t[r] = e[r];
      return t;
    }
    function fe(t, e, r) {
      return t === "parent" ? G(r) : t === "self" ? e.getRect(r) : A(r, t);
    }
    function ye(t, e, r, n) {
      var o = t;
      return S.string(o) ? o = fe(o, e, r) : S.func(o) && (o = o.apply(void 0, n)), S.element(o) && (o = Oe(o)), o;
    }
    function Me(t) {
      return t && { x: "x" in t ? t.x : t.left, y: "y" in t ? t.y : t.top };
    }
    function ze(t) {
      return !t || "x" in t && "y" in t || ((t = F({}, t)).x = t.left || 0, t.y = t.top || 0, t.width = t.width || (t.right || 0) - t.x, t.height = t.height || (t.bottom || 0) - t.y), t;
    }
    function mt(t, e, r) {
      t.left && (e.left += r.x), t.right && (e.right += r.x), t.top && (e.top += r.y), t.bottom && (e.bottom += r.y), e.width = e.right - e.left, e.height = e.bottom - e.top;
    }
    function it(t, e, r) {
      var n = r && t.options[r];
      return Me(ye(n && n.origin || t.options.origin, t, e, [t && e])) || { x: 0, y: 0 };
    }
    function Ue(t, e) {
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function(h) {
        return !0;
      }, n = arguments.length > 3 ? arguments[3] : void 0;
      if (n = n || {}, S.string(t) && t.search(" ") !== -1 && (t = Xr(t)), S.array(t)) return t.forEach(function(h) {
        return Ue(h, e, r, n);
      }), n;
      if (S.object(t) && (e = t, t = ""), S.func(e) && r(t)) n[t] = n[t] || [], n[t].push(e);
      else if (S.array(e)) for (var o = 0, l = e; o < l.length; o++) {
        var c = l[o];
        Ue(t, c, r, n);
      }
      else if (S.object(e)) for (var p in e)
        Ue(Xr(p).map(function(h) {
          return "".concat(t).concat(h);
        }), e[p], r, n);
      return n;
    }
    function Xr(t) {
      return t.trim().split(/ +/);
    }
    var ot = function(t, e) {
      return Math.sqrt(t * t + e * e);
    }, io = ["webkit", "moz"];
    function bt(t, e) {
      t.__set || (t.__set = {});
      var r = function(o) {
        if (io.some(function(l) {
          return o.indexOf(l) === 0;
        })) return 1;
        typeof t[o] != "function" && o !== "__set" && Object.defineProperty(t, o, { get: function() {
          return o in t.__set ? t.__set[o] : t.__set[o] = e[o];
        }, set: function(l) {
          t.__set[o] = l;
        }, configurable: !0 });
      };
      for (var n in e) r(n);
      return t;
    }
    function yt(t, e) {
      t.page = t.page || {}, t.page.x = e.page.x, t.page.y = e.page.y, t.client = t.client || {}, t.client.x = e.client.x, t.client.y = e.client.y, t.timeStamp = e.timeStamp;
    }
    function Br(t) {
      t.page.x = 0, t.page.y = 0, t.client.x = 0, t.client.y = 0;
    }
    function Vr(t) {
      return t instanceof W.Event || t instanceof W.Touch;
    }
    function Tt(t, e, r) {
      return t = t || "page", (r = r || {}).x = e[t + "X"], r.y = e[t + "Y"], r;
    }
    function qr(t, e) {
      return e = e || { x: 0, y: 0 }, $.isOperaMobile && Vr(t) ? (Tt("screen", t, e), e.x += window.scrollX, e.y += window.scrollY) : Tt("page", t, e), e;
    }
    function st(t) {
      return S.number(t.pointerId) ? t.pointerId : t.identifier;
    }
    function oo(t, e, r) {
      var n = e.length > 1 ? Zr(e) : e[0];
      qr(n, t.page), function(o, l) {
        l = l || {}, $.isOperaMobile && Vr(o) ? Tt("screen", o, l) : Tt("client", o, l);
      }(n, t.client), t.timeStamp = r;
    }
    function Bt(t) {
      var e = [];
      return S.array(t) ? (e[0] = t[0], e[1] = t[1]) : t.type === "touchend" ? t.touches.length === 1 ? (e[0] = t.touches[0], e[1] = t.changedTouches[0]) : t.touches.length === 0 && (e[0] = t.changedTouches[0], e[1] = t.changedTouches[1]) : (e[0] = t.touches[0], e[1] = t.touches[1]), e;
    }
    function Zr(t) {
      for (var e = { pageX: 0, pageY: 0, clientX: 0, clientY: 0, screenX: 0, screenY: 0 }, r = 0; r < t.length; r++) {
        var n = t[r];
        for (var o in e) e[o] += n[o];
      }
      for (var l in e) e[l] /= t.length;
      return e;
    }
    function Vt(t) {
      if (!t.length) return null;
      var e = Bt(t), r = Math.min(e[0].pageX, e[1].pageX), n = Math.min(e[0].pageY, e[1].pageY), o = Math.max(e[0].pageX, e[1].pageX), l = Math.max(e[0].pageY, e[1].pageY);
      return { x: r, y: n, left: r, top: n, right: o, bottom: l, width: o - r, height: l - n };
    }
    function qt(t, e) {
      var r = e + "X", n = e + "Y", o = Bt(t), l = o[0][r] - o[1][r], c = o[0][n] - o[1][n];
      return ot(l, c);
    }
    function Zt(t, e) {
      var r = e + "X", n = e + "Y", o = Bt(t), l = o[1][r] - o[0][r], c = o[1][n] - o[0][n];
      return 180 * Math.atan2(c, l) / Math.PI;
    }
    function Jr(t) {
      return S.string(t.pointerType) ? t.pointerType : S.number(t.pointerType) ? [void 0, void 0, "touch", "pen", "mouse"][t.pointerType] : /touch/.test(t.type || "") || t instanceof W.Touch ? "touch" : "mouse";
    }
    function Qr(t) {
      var e = S.func(t.composedPath) ? t.composedPath() : t.path;
      return [he(e ? e[0] : t.target), he(t.currentTarget)];
    }
    var wt = function() {
      function t(e) {
        v(this, t), this.immediatePropagationStopped = !1, this.propagationStopped = !1, this._interaction = e;
      }
      return y(t, [{ key: "preventDefault", value: function() {
      } }, { key: "stopPropagation", value: function() {
        this.propagationStopped = !0;
      } }, { key: "stopImmediatePropagation", value: function() {
        this.immediatePropagationStopped = this.propagationStopped = !0;
      } }]), t;
    }();
    Object.defineProperty(wt.prototype, "interaction", { get: function() {
      return this._interaction._proxy;
    }, set: function() {
    } });
    var en = function(t, e) {
      for (var r = 0; r < e.length; r++) {
        var n = e[r];
        t.push(n);
      }
      return t;
    }, tn = function(t) {
      return en([], t);
    }, at = function(t, e) {
      for (var r = 0; r < t.length; r++) if (e(t[r], r, t)) return r;
      return -1;
    }, lt = function(t, e) {
      return t[at(t, e)];
    }, Be = function(t) {
      O(r, t);
      var e = C(r);
      function r(n, o, l) {
        var c;
        v(this, r), (c = e.call(this, o._interaction)).dropzone = void 0, c.dragEvent = void 0, c.relatedTarget = void 0, c.draggable = void 0, c.propagationStopped = !1, c.immediatePropagationStopped = !1;
        var p = l === "dragleave" ? n.prev : n.cur, h = p.element, g = p.dropzone;
        return c.type = l, c.target = h, c.currentTarget = h, c.dropzone = g, c.dragEvent = o, c.relatedTarget = o.target, c.draggable = o.interactable, c.timeStamp = o.timeStamp, c;
      }
      return y(r, [{ key: "reject", value: function() {
        var n = this, o = this._interaction.dropState;
        if (this.type === "dropactivate" || this.dropzone && o.cur.dropzone === this.dropzone && o.cur.element === this.target) if (o.prev.dropzone = this.dropzone, o.prev.element = this.target, o.rejected = !0, o.events.enter = null, this.stopImmediatePropagation(), this.type === "dropactivate") {
          var l = o.activeDrops, c = at(l, function(h) {
            var g = h.dropzone, d = h.element;
            return g === n.dropzone && d === n.target;
          });
          o.activeDrops.splice(c, 1);
          var p = new r(o, this.dragEvent, "dropdeactivate");
          p.dropzone = this.dropzone, p.target = this.target, this.dropzone.fire(p);
        } else this.dropzone.fire(new r(o, this.dragEvent, "dragleave"));
      } }, { key: "preventDefault", value: function() {
      } }, { key: "stopPropagation", value: function() {
        this.propagationStopped = !0;
      } }, { key: "stopImmediatePropagation", value: function() {
        this.immediatePropagationStopped = this.propagationStopped = !0;
      } }]), r;
    }(wt);
    function rn(t, e) {
      for (var r = 0, n = t.slice(); r < n.length; r++) {
        var o = n[r], l = o.dropzone, c = o.element;
        e.dropzone = l, e.target = c, l.fire(e), e.propagationStopped = e.immediatePropagationStopped = !1;
      }
    }
    function Jt(t, e) {
      for (var r = function(l, c) {
        for (var p = [], h = 0, g = l.interactables.list; h < g.length; h++) {
          var d = g[h];
          if (d.options.drop.enabled) {
            var b = d.options.drop.accept;
            if (!(S.element(b) && b !== c || S.string(b) && !K(c, b) || S.func(b) && !b({ dropzone: d, draggableElement: c }))) for (var w = 0, I = d.getAllElements(); w < I.length; w++) {
              var E = I[w];
              E !== c && p.push({ dropzone: d, element: E, rect: d.getRect(E) });
            }
          }
        }
        return p;
      }(t, e), n = 0; n < r.length; n++) {
        var o = r[n];
        o.rect = o.dropzone.getRect(o.element);
      }
      return r;
    }
    function nn(t, e, r) {
      for (var n = t.dropState, o = t.interactable, l = t.element, c = [], p = 0, h = n.activeDrops; p < h.length; p++) {
        var g = h[p], d = g.dropzone, b = g.element, w = g.rect, I = d.dropCheck(e, r, o, l, b, w);
        c.push(I ? b : null);
      }
      var E = function(D) {
        for (var L, j, N, q = [], Q = 0; Q < D.length; Q++) {
          var B = D[Q], Z = D[L];
          if (B && Q !== L) if (Z) {
            var me = ie(B), le = ie(Z);
            if (me !== B.ownerDocument) if (le !== B.ownerDocument) if (me !== le) {
              q = q.length ? q : ae(Z);
              var Te = void 0;
              if (Z instanceof W.HTMLElement && B instanceof W.SVGElement && !(B instanceof W.SVGSVGElement)) {
                if (B === le) continue;
                Te = B.ownerSVGElement;
              } else Te = B;
              for (var Se = ae(Te, Z.ownerDocument), Pe = 0; Se[Pe] && Se[Pe] === q[Pe]; ) Pe++;
              var Pt = [Se[Pe - 1], Se[Pe], q[Pe]];
              if (Pt[0]) for (var ft = Pt[0].lastChild; ft; ) {
                if (ft === Pt[1]) {
                  L = Q, q = Se;
                  break;
                }
                if (ft === Pt[2]) break;
                ft = ft.previousSibling;
              }
            } else N = Z, (parseInt(te(j = B).getComputedStyle(j).zIndex, 10) || 0) >= (parseInt(te(N).getComputedStyle(N).zIndex, 10) || 0) && (L = Q);
            else L = Q;
          } else L = Q;
        }
        return L;
      }(c);
      return n.activeDrops[E] || null;
    }
    function Qt(t, e, r) {
      var n = t.dropState, o = { enter: null, leave: null, activate: null, deactivate: null, move: null, drop: null };
      return r.type === "dragstart" && (o.activate = new Be(n, r, "dropactivate"), o.activate.target = null, o.activate.dropzone = null), r.type === "dragend" && (o.deactivate = new Be(n, r, "dropdeactivate"), o.deactivate.target = null, o.deactivate.dropzone = null), n.rejected || (n.cur.element !== n.prev.element && (n.prev.dropzone && (o.leave = new Be(n, r, "dragleave"), r.dragLeave = o.leave.target = n.prev.element, r.prevDropzone = o.leave.dropzone = n.prev.dropzone), n.cur.dropzone && (o.enter = new Be(n, r, "dragenter"), r.dragEnter = n.cur.element, r.dropzone = n.cur.dropzone)), r.type === "dragend" && n.cur.dropzone && (o.drop = new Be(n, r, "drop"), r.dropzone = n.cur.dropzone, r.relatedTarget = n.cur.element), r.type === "dragmove" && n.cur.dropzone && (o.move = new Be(n, r, "dropmove"), r.dropzone = n.cur.dropzone)), o;
    }
    function er(t, e) {
      var r = t.dropState, n = r.activeDrops, o = r.cur, l = r.prev;
      e.leave && l.dropzone.fire(e.leave), e.enter && o.dropzone.fire(e.enter), e.move && o.dropzone.fire(e.move), e.drop && o.dropzone.fire(e.drop), e.deactivate && rn(n, e.deactivate), r.prev.dropzone = o.dropzone, r.prev.element = o.element;
    }
    function on(t, e) {
      var r = t.interaction, n = t.iEvent, o = t.event;
      if (n.type === "dragmove" || n.type === "dragend") {
        var l = r.dropState;
        e.dynamicDrop && (l.activeDrops = Jt(e, r.element));
        var c = n, p = nn(r, c, o);
        l.rejected = l.rejected && !!p && p.dropzone === l.cur.dropzone && p.element === l.cur.element, l.cur.dropzone = p && p.dropzone, l.cur.element = p && p.element, l.events = Qt(r, 0, c);
      }
    }
    var sn = { id: "actions/drop", install: function(t) {
      var e = t.actions, r = t.interactStatic, n = t.Interactable, o = t.defaults;
      t.usePlugin(re), n.prototype.dropzone = function(l) {
        return function(c, p) {
          if (S.object(p)) {
            if (c.options.drop.enabled = p.enabled !== !1, p.listeners) {
              var h = Ue(p.listeners), g = Object.keys(h).reduce(function(b, w) {
                return b[/^(enter|leave)/.test(w) ? "drag".concat(w) : /^(activate|deactivate|move)/.test(w) ? "drop".concat(w) : w] = h[w], b;
              }, {}), d = c.options.drop.listeners;
              d && c.off(d), c.on(g), c.options.drop.listeners = g;
            }
            return S.func(p.ondrop) && c.on("drop", p.ondrop), S.func(p.ondropactivate) && c.on("dropactivate", p.ondropactivate), S.func(p.ondropdeactivate) && c.on("dropdeactivate", p.ondropdeactivate), S.func(p.ondragenter) && c.on("dragenter", p.ondragenter), S.func(p.ondragleave) && c.on("dragleave", p.ondragleave), S.func(p.ondropmove) && c.on("dropmove", p.ondropmove), /^(pointer|center)$/.test(p.overlap) ? c.options.drop.overlap = p.overlap : S.number(p.overlap) && (c.options.drop.overlap = Math.max(Math.min(1, p.overlap), 0)), "accept" in p && (c.options.drop.accept = p.accept), "checker" in p && (c.options.drop.checker = p.checker), c;
          }
          return S.bool(p) ? (c.options.drop.enabled = p, c) : c.options.drop;
        }(this, l);
      }, n.prototype.dropCheck = function(l, c, p, h, g, d) {
        return function(b, w, I, E, D, L, j) {
          var N = !1;
          if (!(j = j || b.getRect(L))) return !!b.options.drop.checker && b.options.drop.checker(w, I, N, b, L, E, D);
          var q = b.options.drop.overlap;
          if (q === "pointer") {
            var Q = it(E, D, "drag"), B = qr(w);
            B.x += Q.x, B.y += Q.y;
            var Z = B.x > j.left && B.x < j.right, me = B.y > j.top && B.y < j.bottom;
            N = Z && me;
          }
          var le = E.getRect(D);
          if (le && q === "center") {
            var Te = le.left + le.width / 2, Se = le.top + le.height / 2;
            N = Te >= j.left && Te <= j.right && Se >= j.top && Se <= j.bottom;
          }
          return le && S.number(q) && (N = Math.max(0, Math.min(j.right, le.right) - Math.max(j.left, le.left)) * Math.max(0, Math.min(j.bottom, le.bottom) - Math.max(j.top, le.top)) / (le.width * le.height) >= q), b.options.drop.checker && (N = b.options.drop.checker(w, I, N, b, L, E, D)), N;
        }(this, l, c, p, h, g, d);
      }, r.dynamicDrop = function(l) {
        return S.bool(l) ? (t.dynamicDrop = l, r) : t.dynamicDrop;
      }, F(e.phaselessTypes, { dragenter: !0, dragleave: !0, dropactivate: !0, dropdeactivate: !0, dropmove: !0, drop: !0 }), e.methodDict.drop = "dropzone", t.dynamicDrop = !1, o.actions.drop = sn.defaults;
    }, listeners: { "interactions:before-action-start": function(t) {
      var e = t.interaction;
      e.prepared.name === "drag" && (e.dropState = { cur: { dropzone: null, element: null }, prev: { dropzone: null, element: null }, rejected: null, events: null, activeDrops: [] });
    }, "interactions:after-action-start": function(t, e) {
      var r = t.interaction, n = (t.event, t.iEvent);
      if (r.prepared.name === "drag") {
        var o = r.dropState;
        o.activeDrops = [], o.events = {}, o.activeDrops = Jt(e, r.element), o.events = Qt(r, 0, n), o.events.activate && (rn(o.activeDrops, o.events.activate), e.fire("actions/drop:start", { interaction: r, dragEvent: n }));
      }
    }, "interactions:action-move": on, "interactions:after-action-move": function(t, e) {
      var r = t.interaction, n = t.iEvent;
      if (r.prepared.name === "drag") {
        var o = r.dropState;
        er(r, o.events), e.fire("actions/drop:move", { interaction: r, dragEvent: n }), o.events = {};
      }
    }, "interactions:action-end": function(t, e) {
      if (t.interaction.prepared.name === "drag") {
        var r = t.interaction, n = t.iEvent;
        on(t, e), er(r, r.dropState.events), e.fire("actions/drop:end", { interaction: r, dragEvent: n });
      }
    }, "interactions:stop": function(t) {
      var e = t.interaction;
      if (e.prepared.name === "drag") {
        var r = e.dropState;
        r && (r.activeDrops = null, r.events = null, r.cur.dropzone = null, r.cur.element = null, r.prev.dropzone = null, r.prev.element = null, r.rejected = !1);
      }
    } }, getActiveDrops: Jt, getDrop: nn, getDropEvents: Qt, fireDropEvents: er, filterEventType: function(t) {
      return t.search("drag") === 0 || t.search("drop") === 0;
    }, defaults: { enabled: !1, accept: null, overlap: "pointer" } }, so = sn;
    function tr(t) {
      var e = t.interaction, r = t.iEvent, n = t.phase;
      if (e.prepared.name === "gesture") {
        var o = e.pointers.map(function(g) {
          return g.pointer;
        }), l = n === "start", c = n === "end", p = e.interactable.options.deltaSource;
        if (r.touches = [o[0], o[1]], l) r.distance = qt(o, p), r.box = Vt(o), r.scale = 1, r.ds = 0, r.angle = Zt(o, p), r.da = 0, e.gesture.startDistance = r.distance, e.gesture.startAngle = r.angle;
        else if (c || e.pointers.length < 2) {
          var h = e.prevEvent;
          r.distance = h.distance, r.box = h.box, r.scale = h.scale, r.ds = 0, r.angle = h.angle, r.da = 0;
        } else r.distance = qt(o, p), r.box = Vt(o), r.scale = r.distance / e.gesture.startDistance, r.angle = Zt(o, p), r.ds = r.scale - e.gesture.scale, r.da = r.angle - e.gesture.angle;
        e.gesture.distance = r.distance, e.gesture.angle = r.angle, S.number(r.scale) && r.scale !== 1 / 0 && !isNaN(r.scale) && (e.gesture.scale = r.scale);
      }
    }
    var rr = { id: "actions/gesture", before: ["actions/drag", "actions/resize"], install: function(t) {
      var e = t.actions, r = t.Interactable, n = t.defaults;
      r.prototype.gesturable = function(o) {
        return S.object(o) ? (this.options.gesture.enabled = o.enabled !== !1, this.setPerAction("gesture", o), this.setOnEvents("gesture", o), this) : S.bool(o) ? (this.options.gesture.enabled = o, this) : this.options.gesture;
      }, e.map.gesture = rr, e.methodDict.gesture = "gesturable", n.actions.gesture = rr.defaults;
    }, listeners: { "interactions:action-start": tr, "interactions:action-move": tr, "interactions:action-end": tr, "interactions:new": function(t) {
      t.interaction.gesture = { angle: 0, distance: 0, scale: 1, startAngle: 0, startDistance: 0 };
    }, "auto-start:check": function(t) {
      if (!(t.interaction.pointers.length < 2)) {
        var e = t.interactable.options.gesture;
        if (e && e.enabled) return t.action = { name: "gesture" }, !1;
      }
    } }, defaults: {}, getCursor: function() {
      return "";
    }, filterEventType: function(t) {
      return t.search("gesture") === 0;
    } }, ao = rr;
    function lo(t, e, r, n, o, l, c) {
      if (!e) return !1;
      if (e === !0) {
        var p = S.number(l.width) ? l.width : l.right - l.left, h = S.number(l.height) ? l.height : l.bottom - l.top;
        if (c = Math.min(c, Math.abs((t === "left" || t === "right" ? p : h) / 2)), p < 0 && (t === "left" ? t = "right" : t === "right" && (t = "left")), h < 0 && (t === "top" ? t = "bottom" : t === "bottom" && (t = "top")), t === "left") {
          var g = p >= 0 ? l.left : l.right;
          return r.x < g + c;
        }
        if (t === "top") {
          var d = h >= 0 ? l.top : l.bottom;
          return r.y < d + c;
        }
        if (t === "right") return r.x > (p >= 0 ? l.right : l.left) - c;
        if (t === "bottom") return r.y > (h >= 0 ? l.bottom : l.top) - c;
      }
      return !!S.element(n) && (S.element(e) ? e === n : pe(n, e, o));
    }
    function an(t) {
      var e = t.iEvent, r = t.interaction;
      if (r.prepared.name === "resize" && r.resizeAxes) {
        var n = e;
        r.interactable.options.resize.square ? (r.resizeAxes === "y" ? n.delta.x = n.delta.y : n.delta.y = n.delta.x, n.axes = "xy") : (n.axes = r.resizeAxes, r.resizeAxes === "x" ? n.delta.y = 0 : r.resizeAxes === "y" && (n.delta.x = 0));
      }
    }
    var Ee, Ne, Ie = { id: "actions/resize", before: ["actions/drag"], install: function(t) {
      var e = t.actions, r = t.browser, n = t.Interactable, o = t.defaults;
      Ie.cursors = function(l) {
        return l.isIe9 ? { x: "e-resize", y: "s-resize", xy: "se-resize", top: "n-resize", left: "w-resize", bottom: "s-resize", right: "e-resize", topleft: "se-resize", bottomright: "se-resize", topright: "ne-resize", bottomleft: "ne-resize" } : { x: "ew-resize", y: "ns-resize", xy: "nwse-resize", top: "ns-resize", left: "ew-resize", bottom: "ns-resize", right: "ew-resize", topleft: "nwse-resize", bottomright: "nwse-resize", topright: "nesw-resize", bottomleft: "nesw-resize" };
      }(r), Ie.defaultMargin = r.supportsTouch || r.supportsPointerEvent ? 20 : 10, n.prototype.resizable = function(l) {
        return function(c, p, h) {
          return S.object(p) ? (c.options.resize.enabled = p.enabled !== !1, c.setPerAction("resize", p), c.setOnEvents("resize", p), S.string(p.axis) && /^x$|^y$|^xy$/.test(p.axis) ? c.options.resize.axis = p.axis : p.axis === null && (c.options.resize.axis = h.defaults.actions.resize.axis), S.bool(p.preserveAspectRatio) ? c.options.resize.preserveAspectRatio = p.preserveAspectRatio : S.bool(p.square) && (c.options.resize.square = p.square), c) : S.bool(p) ? (c.options.resize.enabled = p, c) : c.options.resize;
        }(this, l, t);
      }, e.map.resize = Ie, e.methodDict.resize = "resizable", o.actions.resize = Ie.defaults;
    }, listeners: { "interactions:new": function(t) {
      t.interaction.resizeAxes = "xy";
    }, "interactions:action-start": function(t) {
      (function(e) {
        var r = e.iEvent, n = e.interaction;
        if (n.prepared.name === "resize" && n.prepared.edges) {
          var o = r, l = n.rect;
          n._rects = { start: F({}, l), corrected: F({}, l), previous: F({}, l), delta: { left: 0, right: 0, width: 0, top: 0, bottom: 0, height: 0 } }, o.edges = n.prepared.edges, o.rect = n._rects.corrected, o.deltaRect = n._rects.delta;
        }
      })(t), an(t);
    }, "interactions:action-move": function(t) {
      (function(e) {
        var r = e.iEvent, n = e.interaction;
        if (n.prepared.name === "resize" && n.prepared.edges) {
          var o = r, l = n.interactable.options.resize.invert, c = l === "reposition" || l === "negate", p = n.rect, h = n._rects, g = h.start, d = h.corrected, b = h.delta, w = h.previous;
          if (F(w, d), c) {
            if (F(d, p), l === "reposition") {
              if (d.top > d.bottom) {
                var I = d.top;
                d.top = d.bottom, d.bottom = I;
              }
              if (d.left > d.right) {
                var E = d.left;
                d.left = d.right, d.right = E;
              }
            }
          } else d.top = Math.min(p.top, g.bottom), d.bottom = Math.max(p.bottom, g.top), d.left = Math.min(p.left, g.right), d.right = Math.max(p.right, g.left);
          for (var D in d.width = d.right - d.left, d.height = d.bottom - d.top, d) b[D] = d[D] - w[D];
          o.edges = n.prepared.edges, o.rect = d, o.deltaRect = b;
        }
      })(t), an(t);
    }, "interactions:action-end": function(t) {
      var e = t.iEvent, r = t.interaction;
      if (r.prepared.name === "resize" && r.prepared.edges) {
        var n = e;
        n.edges = r.prepared.edges, n.rect = r._rects.corrected, n.deltaRect = r._rects.delta;
      }
    }, "auto-start:check": function(t) {
      var e = t.interaction, r = t.interactable, n = t.element, o = t.rect, l = t.buttons;
      if (o) {
        var c = F({}, e.coords.cur.page), p = r.options.resize;
        if (p && p.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || l & p.mouseButtons)) {
          if (S.object(p.edges)) {
            var h = { left: !1, right: !1, top: !1, bottom: !1 };
            for (var g in h) h[g] = lo(g, p.edges[g], c, e._latestPointer.eventTarget, n, o, p.margin || Ie.defaultMargin);
            h.left = h.left && !h.right, h.top = h.top && !h.bottom, (h.left || h.right || h.top || h.bottom) && (t.action = { name: "resize", edges: h });
          } else {
            var d = p.axis !== "y" && c.x > o.right - Ie.defaultMargin, b = p.axis !== "x" && c.y > o.bottom - Ie.defaultMargin;
            (d || b) && (t.action = { name: "resize", axes: (d ? "x" : "") + (b ? "y" : "") });
          }
          return !t.action && void 0;
        }
      }
    } }, defaults: { square: !1, preserveAspectRatio: !1, axis: "xy", margin: NaN, edges: null, invert: "none" }, cursors: null, getCursor: function(t) {
      var e = t.edges, r = t.axis, n = t.name, o = Ie.cursors, l = null;
      if (r) l = o[n + r];
      else if (e) {
        for (var c = "", p = 0, h = ["top", "bottom", "left", "right"]; p < h.length; p++) {
          var g = h[p];
          e[g] && (c += g);
        }
        l = o[c];
      }
      return l;
    }, filterEventType: function(t) {
      return t.search("resize") === 0;
    }, defaultMargin: null }, co = Ie, uo = { id: "actions", install: function(t) {
      t.usePlugin(ao), t.usePlugin(co), t.usePlugin(re), t.usePlugin(so);
    } }, ln = 0, Re = { request: function(t) {
      return Ee(t);
    }, cancel: function(t) {
      return Ne(t);
    }, init: function(t) {
      if (Ee = t.requestAnimationFrame, Ne = t.cancelAnimationFrame, !Ee) for (var e = ["ms", "moz", "webkit", "o"], r = 0; r < e.length; r++) {
        var n = e[r];
        Ee = t["".concat(n, "RequestAnimationFrame")], Ne = t["".concat(n, "CancelAnimationFrame")] || t["".concat(n, "CancelRequestAnimationFrame")];
      }
      Ee = Ee && Ee.bind(t), Ne = Ne && Ne.bind(t), Ee || (Ee = function(o) {
        var l = Date.now(), c = Math.max(0, 16 - (l - ln)), p = t.setTimeout(function() {
          o(l + c);
        }, c);
        return ln = l + c, p;
      }, Ne = function(o) {
        return clearTimeout(o);
      });
    } }, V = { defaults: { enabled: !1, margin: 60, container: null, speed: 300 }, now: Date.now, interaction: null, i: 0, x: 0, y: 0, isScrolling: !1, prevTime: 0, margin: 0, speed: 0, start: function(t) {
      V.isScrolling = !0, Re.cancel(V.i), t.autoScroll = V, V.interaction = t, V.prevTime = V.now(), V.i = Re.request(V.scroll);
    }, stop: function() {
      V.isScrolling = !1, V.interaction && (V.interaction.autoScroll = null), Re.cancel(V.i);
    }, scroll: function() {
      var t = V.interaction, e = t.interactable, r = t.element, n = t.prepared.name, o = e.options[n].autoScroll, l = cn(o.container, e, r), c = V.now(), p = (c - V.prevTime) / 1e3, h = o.speed * p;
      if (h >= 1) {
        var g = { x: V.x * h, y: V.y * h };
        if (g.x || g.y) {
          var d = un(l);
          S.window(l) ? l.scrollBy(g.x, g.y) : l && (l.scrollLeft += g.x, l.scrollTop += g.y);
          var b = un(l), w = { x: b.x - d.x, y: b.y - d.y };
          (w.x || w.y) && e.fire({ type: "autoscroll", target: r, interactable: e, delta: w, interaction: t, container: l });
        }
        V.prevTime = c;
      }
      V.isScrolling && (Re.cancel(V.i), V.i = Re.request(V.scroll));
    }, check: function(t, e) {
      var r;
      return (r = t.options[e].autoScroll) == null ? void 0 : r.enabled;
    }, onInteractionMove: function(t) {
      var e = t.interaction, r = t.pointer;
      if (e.interacting() && V.check(e.interactable, e.prepared.name)) if (e.simulation) V.x = V.y = 0;
      else {
        var n, o, l, c, p = e.interactable, h = e.element, g = e.prepared.name, d = p.options[g].autoScroll, b = cn(d.container, p, h);
        if (S.window(b)) c = r.clientX < V.margin, n = r.clientY < V.margin, o = r.clientX > b.innerWidth - V.margin, l = r.clientY > b.innerHeight - V.margin;
        else {
          var w = ve(b);
          c = r.clientX < w.left + V.margin, n = r.clientY < w.top + V.margin, o = r.clientX > w.right - V.margin, l = r.clientY > w.bottom - V.margin;
        }
        V.x = o ? 1 : c ? -1 : 0, V.y = l ? 1 : n ? -1 : 0, V.isScrolling || (V.margin = d.margin, V.speed = d.speed, V.start(e));
      }
    } };
    function cn(t, e, r) {
      return (S.string(t) ? fe(t, e, r) : t) || te(r);
    }
    function un(t) {
      return S.window(t) && (t = window.document.body), { x: t.scrollLeft, y: t.scrollTop };
    }
    var po = { id: "auto-scroll", install: function(t) {
      var e = t.defaults, r = t.actions;
      t.autoScroll = V, V.now = function() {
        return t.now();
      }, r.phaselessTypes.autoscroll = !0, e.perAction.autoScroll = V.defaults;
    }, listeners: { "interactions:new": function(t) {
      t.interaction.autoScroll = null;
    }, "interactions:destroy": function(t) {
      t.interaction.autoScroll = null, V.stop(), V.interaction && (V.interaction = null);
    }, "interactions:stop": V.stop, "interactions:action-move": function(t) {
      return V.onInteractionMove(t);
    } } }, ho = po;
    function ct(t, e) {
      var r = !1;
      return function() {
        return r || (Y.console.warn(e), r = !0), t.apply(this, arguments);
      };
    }
    function nr(t, e) {
      return t.name = e.name, t.axis = e.axis, t.edges = e.edges, t;
    }
    function fo(t) {
      return S.bool(t) ? (this.options.styleCursor = t, this) : t === null ? (delete this.options.styleCursor, this) : this.options.styleCursor;
    }
    function vo(t) {
      return S.func(t) ? (this.options.actionChecker = t, this) : t === null ? (delete this.options.actionChecker, this) : this.options.actionChecker;
    }
    var go = { id: "auto-start/interactableMethods", install: function(t) {
      var e = t.Interactable;
      e.prototype.getAction = function(r, n, o, l) {
        var c = function(p, h, g, d, b) {
          var w = p.getRect(d), I = h.buttons || { 0: 1, 1: 4, 3: 8, 4: 16 }[h.button], E = { action: null, interactable: p, interaction: g, element: d, rect: w, buttons: I };
          return b.fire("auto-start:check", E), E.action;
        }(this, n, o, l, t);
        return this.options.actionChecker ? this.options.actionChecker(r, n, c, this, l, o) : c;
      }, e.prototype.ignoreFrom = ct(function(r) {
        return this._backCompatOption("ignoreFrom", r);
      }, "Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue})."), e.prototype.allowFrom = ct(function(r) {
        return this._backCompatOption("allowFrom", r);
      }, "Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue})."), e.prototype.actionChecker = vo, e.prototype.styleCursor = fo;
    } };
    function pn(t, e, r, n, o) {
      return e.testIgnoreAllow(e.options[t.name], r, n) && e.options[t.name].enabled && St(e, r, t, o) ? t : null;
    }
    function mo(t, e, r, n, o, l, c) {
      for (var p = 0, h = n.length; p < h; p++) {
        var g = n[p], d = o[p], b = g.getAction(e, r, t, d);
        if (b) {
          var w = pn(b, g, d, l, c);
          if (w) return { action: w, interactable: g, element: d };
        }
      }
      return { action: null, interactable: null, element: null };
    }
    function hn(t, e, r, n, o) {
      var l = [], c = [], p = n;
      function h(d) {
        l.push(d), c.push(p);
      }
      for (; S.element(p); ) {
        l = [], c = [], o.interactables.forEachMatch(p, h);
        var g = mo(t, e, r, l, c, n, o);
        if (g.action && !g.interactable.options[g.action.name].manualStart) return g;
        p = G(p);
      }
      return { action: null, interactable: null, element: null };
    }
    function dn(t, e, r) {
      var n = e.action, o = e.interactable, l = e.element;
      n = n || { name: null }, t.interactable = o, t.element = l, nr(t.prepared, n), t.rect = o && n.name ? o.getRect(l) : null, vn(t, r), r.fire("autoStart:prepared", { interaction: t });
    }
    function St(t, e, r, n) {
      var o = t.options, l = o[r.name].max, c = o[r.name].maxPerElement, p = n.autoStart.maxInteractions, h = 0, g = 0, d = 0;
      if (!(l && c && p)) return !1;
      for (var b = 0, w = n.interactions.list; b < w.length; b++) {
        var I = w[b], E = I.prepared.name;
        if (I.interacting() && (++h >= p || I.interactable === t && ((g += E === r.name ? 1 : 0) >= l || I.element === e && (d++, E === r.name && d >= c))))
          return !1;
      }
      return p > 0;
    }
    function fn(t, e) {
      return S.number(t) ? (e.autoStart.maxInteractions = t, this) : e.autoStart.maxInteractions;
    }
    function ir(t, e, r) {
      var n = r.autoStart.cursorElement;
      n && n !== t && (n.style.cursor = ""), t.ownerDocument.documentElement.style.cursor = e, t.style.cursor = e, r.autoStart.cursorElement = e ? t : null;
    }
    function vn(t, e) {
      var r = t.interactable, n = t.element, o = t.prepared;
      if (t.pointerType === "mouse" && r && r.options.styleCursor) {
        var l = "";
        if (o.name) {
          var c = r.options[o.name].cursorChecker;
          l = S.func(c) ? c(o, r, n, t._interacting) : e.actions.map[o.name].getCursor(o);
        }
        ir(t.element, l || "", e);
      } else e.autoStart.cursorElement && ir(e.autoStart.cursorElement, "", e);
    }
    var bo = { id: "auto-start/base", before: ["actions"], install: function(t) {
      var e = t.interactStatic, r = t.defaults;
      t.usePlugin(go), r.base.actionChecker = null, r.base.styleCursor = !0, F(r.perAction, { manualStart: !1, max: 1 / 0, maxPerElement: 1, allowFrom: null, ignoreFrom: null, mouseButtons: 1 }), e.maxInteractions = function(n) {
        return fn(n, t);
      }, t.autoStart = { maxInteractions: 1 / 0, withinInteractionLimit: St, cursorElement: null };
    }, listeners: { "interactions:down": function(t, e) {
      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget;
      r.interacting() || dn(r, hn(r, n, o, l, e), e);
    }, "interactions:move": function(t, e) {
      (function(r, n) {
        var o = r.interaction, l = r.pointer, c = r.event, p = r.eventTarget;
        o.pointerType !== "mouse" || o.pointerIsDown || o.interacting() || dn(o, hn(o, l, c, p, n), n);
      })(t, e), function(r, n) {
        var o = r.interaction;
        if (o.pointerIsDown && !o.interacting() && o.pointerWasMoved && o.prepared.name) {
          n.fire("autoStart:before-start", r);
          var l = o.interactable, c = o.prepared.name;
          c && l && (l.options[c].manualStart || !St(l, o.element, o.prepared, n) ? o.stop() : (o.start(o.prepared, l, o.element), vn(o, n)));
        }
      }(t, e);
    }, "interactions:stop": function(t, e) {
      var r = t.interaction, n = r.interactable;
      n && n.options.styleCursor && ir(r.element, "", e);
    } }, maxInteractions: fn, withinInteractionLimit: St, validateAction: pn }, or = bo, yo = { id: "auto-start/dragAxis", listeners: { "autoStart:before-start": function(t, e) {
      var r = t.interaction, n = t.eventTarget, o = t.dx, l = t.dy;
      if (r.prepared.name === "drag") {
        var c = Math.abs(o), p = Math.abs(l), h = r.interactable.options.drag, g = h.startAxis, d = c > p ? "x" : c < p ? "y" : "xy";
        if (r.prepared.axis = h.lockAxis === "start" ? d[0] : h.lockAxis, d !== "xy" && g !== "xy" && g !== d) {
          r.prepared.name = null;
          for (var b = n, w = function(E) {
            if (E !== r.interactable) {
              var D = r.interactable.options.drag;
              if (!D.manualStart && E.testIgnoreAllow(D, b, n)) {
                var L = E.getAction(r.downPointer, r.downEvent, r, b);
                if (L && L.name === "drag" && function(j, N) {
                  if (!N) return !1;
                  var q = N.options.drag.startAxis;
                  return j === "xy" || q === "xy" || q === j;
                }(d, E) && or.validateAction(L, E, b, n, e)) return E;
              }
            }
          }; S.element(b); ) {
            var I = e.interactables.forEachMatch(b, w);
            if (I) {
              r.prepared.name = "drag", r.interactable = I, r.element = b;
              break;
            }
            b = G(b);
          }
        }
      }
    } } };
    function sr(t) {
      var e = t.prepared && t.prepared.name;
      if (!e) return null;
      var r = t.interactable.options;
      return r[e].hold || r[e].delay;
    }
    var To = { id: "auto-start/hold", install: function(t) {
      var e = t.defaults;
      t.usePlugin(or), e.perAction.hold = 0, e.perAction.delay = 0;
    }, listeners: { "interactions:new": function(t) {
      t.interaction.autoStartHoldTimer = null;
    }, "autoStart:prepared": function(t) {
      var e = t.interaction, r = sr(e);
      r > 0 && (e.autoStartHoldTimer = setTimeout(function() {
        e.start(e.prepared, e.interactable, e.element);
      }, r));
    }, "interactions:move": function(t) {
      var e = t.interaction, r = t.duplicate;
      e.autoStartHoldTimer && e.pointerWasMoved && !r && (clearTimeout(e.autoStartHoldTimer), e.autoStartHoldTimer = null);
    }, "autoStart:before-start": function(t) {
      var e = t.interaction;
      sr(e) > 0 && (e.prepared.name = null);
    } }, getHoldDuration: sr }, wo = To, So = { id: "auto-start", install: function(t) {
      t.usePlugin(or), t.usePlugin(wo), t.usePlugin(yo);
    } }, xo = function(t) {
      return /^(always|never|auto)$/.test(t) ? (this.options.preventDefault = t, this) : S.bool(t) ? (this.options.preventDefault = t ? "always" : "never", this) : this.options.preventDefault;
    };
    function Oo(t) {
      var e = t.interaction, r = t.event;
      e.interactable && e.interactable.checkAndPreventDefault(r);
    }
    var gn = { id: "core/interactablePreventDefault", install: function(t) {
      var e = t.Interactable;
      e.prototype.preventDefault = xo, e.prototype.checkAndPreventDefault = function(r) {
        return function(n, o, l) {
          var c = n.options.preventDefault;
          if (c !== "never") if (c !== "always") {
            if (o.events.supportsPassive && /^touch(start|move)$/.test(l.type)) {
              var p = te(l.target).document, h = o.getDocOptions(p);
              if (!h || !h.events || h.events.passive !== !1) return;
            }
            /^(mouse|pointer|touch)*(down|start)/i.test(l.type) || S.element(l.target) && K(l.target, "input,select,textarea,[contenteditable=true],[contenteditable=true] *") || l.preventDefault();
          } else l.preventDefault();
        }(this, t, r);
      }, t.interactions.docEvents.push({ type: "dragstart", listener: function(r) {
        for (var n = 0, o = t.interactions.list; n < o.length; n++) {
          var l = o[n];
          if (l.element && (l.element === r.target || U(l.element, r.target))) return void l.interactable.checkAndPreventDefault(r);
        }
      } });
    }, listeners: ["down", "move", "up", "cancel"].reduce(function(t, e) {
      return t["interactions:".concat(e)] = Oo, t;
    }, {}) };
    function xt(t, e) {
      if (e.phaselessTypes[t]) return !0;
      for (var r in e.map) if (t.indexOf(r) === 0 && t.substr(r.length) in e.phases) return !0;
      return !1;
    }
    function Ve(t) {
      var e = {};
      for (var r in t) {
        var n = t[r];
        S.plainObject(n) ? e[r] = Ve(n) : S.array(n) ? e[r] = tn(n) : e[r] = n;
      }
      return e;
    }
    var ar = function() {
      function t(e) {
        v(this, t), this.states = [], this.startOffset = { left: 0, right: 0, top: 0, bottom: 0 }, this.startDelta = void 0, this.result = void 0, this.endResult = void 0, this.startEdges = void 0, this.edges = void 0, this.interaction = void 0, this.interaction = e, this.result = Ot(), this.edges = { left: !1, right: !1, top: !1, bottom: !1 };
      }
      return y(t, [{ key: "start", value: function(e, r) {
        var n, o, l = e.phase, c = this.interaction, p = function(g) {
          var d = g.interactable.options[g.prepared.name], b = d.modifiers;
          return b && b.length ? b : ["snap", "snapSize", "snapEdges", "restrict", "restrictEdges", "restrictSize"].map(function(w) {
            var I = d[w];
            return I && I.enabled && { options: I, methods: I._methods };
          }).filter(function(w) {
            return !!w;
          });
        }(c);
        this.prepareStates(p), this.startEdges = F({}, c.edges), this.edges = F({}, this.startEdges), this.startOffset = (n = c.rect, o = r, n ? { left: o.x - n.left, top: o.y - n.top, right: n.right - o.x, bottom: n.bottom - o.y } : { left: 0, top: 0, right: 0, bottom: 0 }), this.startDelta = { x: 0, y: 0 };
        var h = this.fillArg({ phase: l, pageCoords: r, preEnd: !1 });
        return this.result = Ot(), this.startAll(h), this.result = this.setAll(h);
      } }, { key: "fillArg", value: function(e) {
        var r = this.interaction;
        return e.interaction = r, e.interactable = r.interactable, e.element = r.element, e.rect || (e.rect = r.rect), e.edges || (e.edges = this.startEdges), e.startOffset = this.startOffset, e;
      } }, { key: "startAll", value: function(e) {
        for (var r = 0, n = this.states; r < n.length; r++) {
          var o = n[r];
          o.methods.start && (e.state = o, o.methods.start(e));
        }
      } }, { key: "setAll", value: function(e) {
        var r = e.phase, n = e.preEnd, o = e.skipModifiers, l = e.rect, c = e.edges;
        e.coords = F({}, e.pageCoords), e.rect = F({}, l), e.edges = F({}, c);
        for (var p = o ? this.states.slice(o) : this.states, h = Ot(e.coords, e.rect), g = 0; g < p.length; g++) {
          var d, b = p[g], w = b.options, I = F({}, e.coords), E = null;
          (d = b.methods) != null && d.set && this.shouldDo(w, n, r) && (e.state = b, E = b.methods.set(e), mt(e.edges, e.rect, { x: e.coords.x - I.x, y: e.coords.y - I.y })), h.eventProps.push(E);
        }
        F(this.edges, e.edges), h.delta.x = e.coords.x - e.pageCoords.x, h.delta.y = e.coords.y - e.pageCoords.y, h.rectDelta.left = e.rect.left - l.left, h.rectDelta.right = e.rect.right - l.right, h.rectDelta.top = e.rect.top - l.top, h.rectDelta.bottom = e.rect.bottom - l.bottom;
        var D = this.result.coords, L = this.result.rect;
        if (D && L) {
          var j = h.rect.left !== L.left || h.rect.right !== L.right || h.rect.top !== L.top || h.rect.bottom !== L.bottom;
          h.changed = j || D.x !== h.coords.x || D.y !== h.coords.y;
        }
        return h;
      } }, { key: "applyToInteraction", value: function(e) {
        var r = this.interaction, n = e.phase, o = r.coords.cur, l = r.coords.start, c = this.result, p = this.startDelta, h = c.delta;
        n === "start" && F(this.startDelta, c.delta);
        for (var g = 0, d = [[l, p], [o, h]]; g < d.length; g++) {
          var b = d[g], w = b[0], I = b[1];
          w.page.x += I.x, w.page.y += I.y, w.client.x += I.x, w.client.y += I.y;
        }
        var E = this.result.rectDelta, D = e.rect || r.rect;
        D.left += E.left, D.right += E.right, D.top += E.top, D.bottom += E.bottom, D.width = D.right - D.left, D.height = D.bottom - D.top;
      } }, { key: "setAndApply", value: function(e) {
        var r = this.interaction, n = e.phase, o = e.preEnd, l = e.skipModifiers, c = this.setAll(this.fillArg({ preEnd: o, phase: n, pageCoords: e.modifiedCoords || r.coords.cur.page }));
        if (this.result = c, !c.changed && (!l || l < this.states.length) && r.interacting()) return !1;
        if (e.modifiedCoords) {
          var p = r.coords.cur.page, h = { x: e.modifiedCoords.x - p.x, y: e.modifiedCoords.y - p.y };
          c.coords.x += h.x, c.coords.y += h.y, c.delta.x += h.x, c.delta.y += h.y;
        }
        this.applyToInteraction(e);
      } }, { key: "beforeEnd", value: function(e) {
        var r = e.interaction, n = e.event, o = this.states;
        if (o && o.length) {
          for (var l = !1, c = 0; c < o.length; c++) {
            var p = o[c];
            e.state = p;
            var h = p.options, g = p.methods, d = g.beforeEnd && g.beforeEnd(e);
            if (d) return this.endResult = d, !1;
            l = l || !l && this.shouldDo(h, !0, e.phase, !0);
          }
          l && r.move({ event: n, preEnd: !0 });
        }
      } }, { key: "stop", value: function(e) {
        var r = e.interaction;
        if (this.states && this.states.length) {
          var n = F({ states: this.states, interactable: r.interactable, element: r.element, rect: null }, e);
          this.fillArg(n);
          for (var o = 0, l = this.states; o < l.length; o++) {
            var c = l[o];
            n.state = c, c.methods.stop && c.methods.stop(n);
          }
          this.states = null, this.endResult = null;
        }
      } }, { key: "prepareStates", value: function(e) {
        this.states = [];
        for (var r = 0; r < e.length; r++) {
          var n = e[r], o = n.options, l = n.methods, c = n.name;
          this.states.push({ options: o, methods: l, index: r, name: c });
        }
        return this.states;
      } }, { key: "restoreInteractionCoords", value: function(e) {
        var r = e.interaction, n = r.coords, o = r.rect, l = r.modification;
        if (l.result) {
          for (var c = l.startDelta, p = l.result, h = p.delta, g = p.rectDelta, d = 0, b = [[n.start, c], [n.cur, h]]; d < b.length; d++) {
            var w = b[d], I = w[0], E = w[1];
            I.page.x -= E.x, I.page.y -= E.y, I.client.x -= E.x, I.client.y -= E.y;
          }
          o.left -= g.left, o.right -= g.right, o.top -= g.top, o.bottom -= g.bottom;
        }
      } }, { key: "shouldDo", value: function(e, r, n, o) {
        return !(!e || e.enabled === !1 || o && !e.endOnly || e.endOnly && !r || n === "start" && !e.setStart);
      } }, { key: "copyFrom", value: function(e) {
        this.startOffset = e.startOffset, this.startDelta = e.startDelta, this.startEdges = e.startEdges, this.edges = e.edges, this.states = e.states.map(function(r) {
          return Ve(r);
        }), this.result = Ot(F({}, e.result.coords), F({}, e.result.rect));
      } }, { key: "destroy", value: function() {
        for (var e in this) this[e] = null;
      } }]), t;
    }();
    function Ot(t, e) {
      return { rect: e, coords: t, delta: { x: 0, y: 0 }, rectDelta: { left: 0, right: 0, top: 0, bottom: 0 }, eventProps: [], changed: !0 };
    }
    function je(t, e) {
      var r = t.defaults, n = { start: t.start, set: t.set, beforeEnd: t.beforeEnd, stop: t.stop }, o = function(l) {
        var c = l || {};
        for (var p in c.enabled = c.enabled !== !1, r) p in c || (c[p] = r[p]);
        var h = { options: c, methods: n, name: e, enable: function() {
          return c.enabled = !0, h;
        }, disable: function() {
          return c.enabled = !1, h;
        } };
        return h;
      };
      return e && typeof e == "string" && (o._defaults = r, o._methods = n), o;
    }
    function ut(t) {
      var e = t.iEvent, r = t.interaction.modification.result;
      r && (e.modifiers = r.eventProps);
    }
    var _o = { id: "modifiers/base", before: ["actions"], install: function(t) {
      t.defaults.perAction.modifiers = [];
    }, listeners: { "interactions:new": function(t) {
      var e = t.interaction;
      e.modification = new ar(e);
    }, "interactions:before-action-start": function(t) {
      var e = t.interaction, r = t.interaction.modification;
      r.start(t, e.coords.start.page), e.edges = r.edges, r.applyToInteraction(t);
    }, "interactions:before-action-move": function(t) {
      var e = t.interaction, r = e.modification, n = r.setAndApply(t);
      return e.edges = r.edges, n;
    }, "interactions:before-action-end": function(t) {
      var e = t.interaction, r = e.modification, n = r.beforeEnd(t);
      return e.edges = r.startEdges, n;
    }, "interactions:action-start": ut, "interactions:action-move": ut, "interactions:action-end": ut, "interactions:after-action-start": function(t) {
      return t.interaction.modification.restoreInteractionCoords(t);
    }, "interactions:after-action-move": function(t) {
      return t.interaction.modification.restoreInteractionCoords(t);
    }, "interactions:stop": function(t) {
      return t.interaction.modification.stop(t);
    } } }, mn = _o, bn = { base: { preventDefault: "auto", deltaSource: "page" }, perAction: { enabled: !1, origin: { x: 0, y: 0 } }, actions: {} }, lr = function(t) {
      O(r, t);
      var e = C(r);
      function r(n, o, l, c, p, h, g) {
        var d;
        v(this, r), (d = e.call(this, n)).relatedTarget = null, d.screenX = void 0, d.screenY = void 0, d.button = void 0, d.buttons = void 0, d.ctrlKey = void 0, d.shiftKey = void 0, d.altKey = void 0, d.metaKey = void 0, d.page = void 0, d.client = void 0, d.delta = void 0, d.rect = void 0, d.x0 = void 0, d.y0 = void 0, d.t0 = void 0, d.dt = void 0, d.duration = void 0, d.clientX0 = void 0, d.clientY0 = void 0, d.velocity = void 0, d.speed = void 0, d.swipe = void 0, d.axes = void 0, d.preEnd = void 0, p = p || n.element;
        var b = n.interactable, w = (b && b.options || bn).deltaSource, I = it(b, p, l), E = c === "start", D = c === "end", L = E ? T(d) : n.prevEvent, j = E ? n.coords.start : D ? { page: L.page, client: L.client, timeStamp: n.coords.cur.timeStamp } : n.coords.cur;
        return d.page = F({}, j.page), d.client = F({}, j.client), d.rect = F({}, n.rect), d.timeStamp = j.timeStamp, D || (d.page.x -= I.x, d.page.y -= I.y, d.client.x -= I.x, d.client.y -= I.y), d.ctrlKey = o.ctrlKey, d.altKey = o.altKey, d.shiftKey = o.shiftKey, d.metaKey = o.metaKey, d.button = o.button, d.buttons = o.buttons, d.target = p, d.currentTarget = p, d.preEnd = h, d.type = g || l + (c || ""), d.interactable = b, d.t0 = E ? n.pointers[n.pointers.length - 1].downTime : L.t0, d.x0 = n.coords.start.page.x - I.x, d.y0 = n.coords.start.page.y - I.y, d.clientX0 = n.coords.start.client.x - I.x, d.clientY0 = n.coords.start.client.y - I.y, d.delta = E || D ? { x: 0, y: 0 } : { x: d[w].x - L[w].x, y: d[w].y - L[w].y }, d.dt = n.coords.delta.timeStamp, d.duration = d.timeStamp - d.t0, d.velocity = F({}, n.coords.velocity[w]), d.speed = ot(d.velocity.x, d.velocity.y), d.swipe = D || c === "inertiastart" ? d.getSwipe() : null, d;
      }
      return y(r, [{ key: "getSwipe", value: function() {
        var n = this._interaction;
        if (n.prevEvent.speed < 600 || this.timeStamp - n.prevEvent.timeStamp > 150) return null;
        var o = 180 * Math.atan2(n.prevEvent.velocityY, n.prevEvent.velocityX) / Math.PI;
        o < 0 && (o += 360);
        var l = 112.5 <= o && o < 247.5, c = 202.5 <= o && o < 337.5;
        return { up: c, down: !c && 22.5 <= o && o < 157.5, left: l, right: !l && (292.5 <= o || o < 67.5), angle: o, speed: n.prevEvent.speed, velocity: { x: n.prevEvent.velocityX, y: n.prevEvent.velocityY } };
      } }, { key: "preventDefault", value: function() {
      } }, { key: "stopImmediatePropagation", value: function() {
        this.immediatePropagationStopped = this.propagationStopped = !0;
      } }, { key: "stopPropagation", value: function() {
        this.propagationStopped = !0;
      } }]), r;
    }(wt);
    Object.defineProperties(lr.prototype, { pageX: { get: function() {
      return this.page.x;
    }, set: function(t) {
      this.page.x = t;
    } }, pageY: { get: function() {
      return this.page.y;
    }, set: function(t) {
      this.page.y = t;
    } }, clientX: { get: function() {
      return this.client.x;
    }, set: function(t) {
      this.client.x = t;
    } }, clientY: { get: function() {
      return this.client.y;
    }, set: function(t) {
      this.client.y = t;
    } }, dx: { get: function() {
      return this.delta.x;
    }, set: function(t) {
      this.delta.x = t;
    } }, dy: { get: function() {
      return this.delta.y;
    }, set: function(t) {
      this.delta.y = t;
    } }, velocityX: { get: function() {
      return this.velocity.x;
    }, set: function(t) {
      this.velocity.x = t;
    } }, velocityY: { get: function() {
      return this.velocity.y;
    }, set: function(t) {
      this.velocity.y = t;
    } } });
    var Mo = y(function t(e, r, n, o, l) {
      v(this, t), this.id = void 0, this.pointer = void 0, this.event = void 0, this.downTime = void 0, this.downTarget = void 0, this.id = e, this.pointer = r, this.event = n, this.downTime = o, this.downTarget = l;
    }), Co = function(t) {
      return t.interactable = "", t.element = "", t.prepared = "", t.pointerIsDown = "", t.pointerWasMoved = "", t._proxy = "", t;
    }({}), yn = function(t) {
      return t.start = "", t.move = "", t.end = "", t.stop = "", t.interacting = "", t;
    }({}), Eo = 0, Io = function() {
      function t(e) {
        var r = this, n = e.pointerType, o = e.scopeFire;
        v(this, t), this.interactable = null, this.element = null, this.rect = null, this._rects = void 0, this.edges = null, this._scopeFire = void 0, this.prepared = { name: null, axis: null, edges: null }, this.pointerType = void 0, this.pointers = [], this.downEvent = null, this.downPointer = {}, this._latestPointer = { pointer: null, event: null, eventTarget: null }, this.prevEvent = null, this.pointerIsDown = !1, this.pointerWasMoved = !1, this._interacting = !1, this._ending = !1, this._stopped = !0, this._proxy = void 0, this.simulation = null, this.doMove = ct(function(d) {
          this.move(d);
        }, "The interaction.doMove() method has been renamed to interaction.move()"), this.coords = { start: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, prev: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, cur: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, delta: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, velocity: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 } }, this._id = Eo++, this._scopeFire = o, this.pointerType = n;
        var l = this;
        this._proxy = {};
        var c = function(d) {
          Object.defineProperty(r._proxy, d, { get: function() {
            return l[d];
          } });
        };
        for (var p in Co) c(p);
        var h = function(d) {
          Object.defineProperty(r._proxy, d, { value: function() {
            return l[d].apply(l, arguments);
          } });
        };
        for (var g in yn) h(g);
        this._scopeFire("interactions:new", { interaction: this });
      }
      return y(t, [{ key: "pointerMoveTolerance", get: function() {
        return 1;
      } }, { key: "pointerDown", value: function(e, r, n) {
        var o = this.updatePointer(e, r, n, !0), l = this.pointers[o];
        this._scopeFire("interactions:down", { pointer: e, event: r, eventTarget: n, pointerIndex: o, pointerInfo: l, type: "down", interaction: this });
      } }, { key: "start", value: function(e, r, n) {
        return !(this.interacting() || !this.pointerIsDown || this.pointers.length < (e.name === "gesture" ? 2 : 1) || !r.options[e.name].enabled) && (nr(this.prepared, e), this.interactable = r, this.element = n, this.rect = r.getRect(n), this.edges = this.prepared.edges ? F({}, this.prepared.edges) : { left: !0, right: !0, top: !0, bottom: !0 }, this._stopped = !1, this._interacting = this._doPhase({ interaction: this, event: this.downEvent, phase: "start" }) && !this._stopped, this._interacting);
      } }, { key: "pointerMove", value: function(e, r, n) {
        this.simulation || this.modification && this.modification.endResult || this.updatePointer(e, r, n, !1);
        var o, l, c = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;
        this.pointerIsDown && !this.pointerWasMoved && (o = this.coords.cur.client.x - this.coords.start.client.x, l = this.coords.cur.client.y - this.coords.start.client.y, this.pointerWasMoved = ot(o, l) > this.pointerMoveTolerance);
        var p, h, g, d = this.getPointerIndex(e), b = { pointer: e, pointerIndex: d, pointerInfo: this.pointers[d], event: r, type: "move", eventTarget: n, dx: o, dy: l, duplicate: c, interaction: this };
        c || (p = this.coords.velocity, h = this.coords.delta, g = Math.max(h.timeStamp / 1e3, 1e-3), p.page.x = h.page.x / g, p.page.y = h.page.y / g, p.client.x = h.client.x / g, p.client.y = h.client.y / g, p.timeStamp = g), this._scopeFire("interactions:move", b), c || this.simulation || (this.interacting() && (b.type = null, this.move(b)), this.pointerWasMoved && yt(this.coords.prev, this.coords.cur));
      } }, { key: "move", value: function(e) {
        e && e.event || Br(this.coords.delta), (e = F({ pointer: this._latestPointer.pointer, event: this._latestPointer.event, eventTarget: this._latestPointer.eventTarget, interaction: this }, e || {})).phase = "move", this._doPhase(e);
      } }, { key: "pointerUp", value: function(e, r, n, o) {
        var l = this.getPointerIndex(e);
        l === -1 && (l = this.updatePointer(e, r, n, !1));
        var c = /cancel$/i.test(r.type) ? "cancel" : "up";
        this._scopeFire("interactions:".concat(c), { pointer: e, pointerIndex: l, pointerInfo: this.pointers[l], event: r, eventTarget: n, type: c, curEventTarget: o, interaction: this }), this.simulation || this.end(r), this.removePointer(e, r);
      } }, { key: "documentBlur", value: function(e) {
        this.end(e), this._scopeFire("interactions:blur", { event: e, type: "blur", interaction: this });
      } }, { key: "end", value: function(e) {
        var r;
        this._ending = !0, e = e || this._latestPointer.event, this.interacting() && (r = this._doPhase({ event: e, interaction: this, phase: "end" })), this._ending = !1, r === !0 && this.stop();
      } }, { key: "currentAction", value: function() {
        return this._interacting ? this.prepared.name : null;
      } }, { key: "interacting", value: function() {
        return this._interacting;
      } }, { key: "stop", value: function() {
        this._scopeFire("interactions:stop", { interaction: this }), this.interactable = this.element = null, this._interacting = !1, this._stopped = !0, this.prepared.name = this.prevEvent = null;
      } }, { key: "getPointerIndex", value: function(e) {
        var r = st(e);
        return this.pointerType === "mouse" || this.pointerType === "pen" ? this.pointers.length - 1 : at(this.pointers, function(n) {
          return n.id === r;
        });
      } }, { key: "getPointerInfo", value: function(e) {
        return this.pointers[this.getPointerIndex(e)];
      } }, { key: "updatePointer", value: function(e, r, n, o) {
        var l, c, p, h = st(e), g = this.getPointerIndex(e), d = this.pointers[g];
        return o = o !== !1 && (o || /(down|start)$/i.test(r.type)), d ? d.pointer = e : (d = new Mo(h, e, r, null, null), g = this.pointers.length, this.pointers.push(d)), oo(this.coords.cur, this.pointers.map(function(b) {
          return b.pointer;
        }), this._now()), l = this.coords.delta, c = this.coords.prev, p = this.coords.cur, l.page.x = p.page.x - c.page.x, l.page.y = p.page.y - c.page.y, l.client.x = p.client.x - c.client.x, l.client.y = p.client.y - c.client.y, l.timeStamp = p.timeStamp - c.timeStamp, o && (this.pointerIsDown = !0, d.downTime = this.coords.cur.timeStamp, d.downTarget = n, bt(this.downPointer, e), this.interacting() || (yt(this.coords.start, this.coords.cur), yt(this.coords.prev, this.coords.cur), this.downEvent = r, this.pointerWasMoved = !1)), this._updateLatestPointer(e, r, n), this._scopeFire("interactions:update-pointer", { pointer: e, event: r, eventTarget: n, down: o, pointerInfo: d, pointerIndex: g, interaction: this }), g;
      } }, { key: "removePointer", value: function(e, r) {
        var n = this.getPointerIndex(e);
        if (n !== -1) {
          var o = this.pointers[n];
          this._scopeFire("interactions:remove-pointer", { pointer: e, event: r, eventTarget: null, pointerIndex: n, pointerInfo: o, interaction: this }), this.pointers.splice(n, 1), this.pointerIsDown = !1;
        }
      } }, { key: "_updateLatestPointer", value: function(e, r, n) {
        this._latestPointer.pointer = e, this._latestPointer.event = r, this._latestPointer.eventTarget = n;
      } }, { key: "destroy", value: function() {
        this._latestPointer.pointer = null, this._latestPointer.event = null, this._latestPointer.eventTarget = null;
      } }, { key: "_createPreparedEvent", value: function(e, r, n, o) {
        return new lr(this, e, this.prepared.name, r, this.element, n, o);
      } }, { key: "_fireEvent", value: function(e) {
        var r;
        (r = this.interactable) == null || r.fire(e), (!this.prevEvent || e.timeStamp >= this.prevEvent.timeStamp) && (this.prevEvent = e);
      } }, { key: "_doPhase", value: function(e) {
        var r = e.event, n = e.phase, o = e.preEnd, l = e.type, c = this.rect;
        if (c && n === "move" && (mt(this.edges, c, this.coords.delta[this.interactable.options.deltaSource]), c.width = c.right - c.left, c.height = c.bottom - c.top), this._scopeFire("interactions:before-action-".concat(n), e) === !1) return !1;
        var p = e.iEvent = this._createPreparedEvent(r, n, o, l);
        return this._scopeFire("interactions:action-".concat(n), e), n === "start" && (this.prevEvent = p), this._fireEvent(p), this._scopeFire("interactions:after-action-".concat(n), e), !0;
      } }, { key: "_now", value: function() {
        return Date.now();
      } }]), t;
    }();
    function Tn(t) {
      wn(t.interaction);
    }
    function wn(t) {
      if (!function(r) {
        return !(!r.offset.pending.x && !r.offset.pending.y);
      }(t)) return !1;
      var e = t.offset.pending;
      return cr(t.coords.cur, e), cr(t.coords.delta, e), mt(t.edges, t.rect, e), e.x = 0, e.y = 0, !0;
    }
    function Po(t) {
      var e = t.x, r = t.y;
      this.offset.pending.x += e, this.offset.pending.y += r, this.offset.total.x += e, this.offset.total.y += r;
    }
    function cr(t, e) {
      var r = t.page, n = t.client, o = e.x, l = e.y;
      r.x += o, r.y += l, n.x += o, n.y += l;
    }
    yn.offsetBy = "";
    var Do = { id: "offset", before: ["modifiers", "pointer-events", "actions", "inertia"], install: function(t) {
      t.Interaction.prototype.offsetBy = Po;
    }, listeners: { "interactions:new": function(t) {
      t.interaction.offset = { total: { x: 0, y: 0 }, pending: { x: 0, y: 0 } };
    }, "interactions:update-pointer": function(t) {
      return function(e) {
        e.pointerIsDown && (cr(e.coords.cur, e.offset.total), e.offset.pending.x = 0, e.offset.pending.y = 0);
      }(t.interaction);
    }, "interactions:before-action-start": Tn, "interactions:before-action-move": Tn, "interactions:before-action-end": function(t) {
      var e = t.interaction;
      if (wn(e)) return e.move({ offset: !0 }), e.end(), !1;
    }, "interactions:stop": function(t) {
      var e = t.interaction;
      e.offset.total.x = 0, e.offset.total.y = 0, e.offset.pending.x = 0, e.offset.pending.y = 0;
    } } }, Sn = Do, $o = function() {
      function t(e) {
        v(this, t), this.active = !1, this.isModified = !1, this.smoothEnd = !1, this.allowResume = !1, this.modification = void 0, this.modifierCount = 0, this.modifierArg = void 0, this.startCoords = void 0, this.t0 = 0, this.v0 = 0, this.te = 0, this.targetOffset = void 0, this.modifiedOffset = void 0, this.currentOffset = void 0, this.lambda_v0 = 0, this.one_ve_v0 = 0, this.timeout = void 0, this.interaction = void 0, this.interaction = e;
      }
      return y(t, [{ key: "start", value: function(e) {
        var r = this.interaction, n = _t(r);
        if (!n || !n.enabled) return !1;
        var o = r.coords.velocity.client, l = ot(o.x, o.y), c = this.modification || (this.modification = new ar(r));
        if (c.copyFrom(r.modification), this.t0 = r._now(), this.allowResume = n.allowResume, this.v0 = l, this.currentOffset = { x: 0, y: 0 }, this.startCoords = r.coords.cur.page, this.modifierArg = c.fillArg({ pageCoords: this.startCoords, preEnd: !0, phase: "inertiastart" }), this.t0 - r.coords.cur.timeStamp < 50 && l > n.minSpeed && l > n.endSpeed) this.startInertia();
        else {
          if (c.result = c.setAll(this.modifierArg), !c.result.changed) return !1;
          this.startSmoothEnd();
        }
        return r.modification.result.rect = null, r.offsetBy(this.targetOffset), r._doPhase({ interaction: r, event: e, phase: "inertiastart" }), r.offsetBy({ x: -this.targetOffset.x, y: -this.targetOffset.y }), r.modification.result.rect = null, this.active = !0, r.simulation = this, !0;
      } }, { key: "startInertia", value: function() {
        var e = this, r = this.interaction.coords.velocity.client, n = _t(this.interaction), o = n.resistance, l = -Math.log(n.endSpeed / this.v0) / o;
        this.targetOffset = { x: (r.x - l) / o, y: (r.y - l) / o }, this.te = l, this.lambda_v0 = o / this.v0, this.one_ve_v0 = 1 - n.endSpeed / this.v0;
        var c = this.modification, p = this.modifierArg;
        p.pageCoords = { x: this.startCoords.x + this.targetOffset.x, y: this.startCoords.y + this.targetOffset.y }, c.result = c.setAll(p), c.result.changed && (this.isModified = !0, this.modifiedOffset = { x: this.targetOffset.x + c.result.delta.x, y: this.targetOffset.y + c.result.delta.y }), this.onNextFrame(function() {
          return e.inertiaTick();
        });
      } }, { key: "startSmoothEnd", value: function() {
        var e = this;
        this.smoothEnd = !0, this.isModified = !0, this.targetOffset = { x: this.modification.result.delta.x, y: this.modification.result.delta.y }, this.onNextFrame(function() {
          return e.smoothEndTick();
        });
      } }, { key: "onNextFrame", value: function(e) {
        var r = this;
        this.timeout = Re.request(function() {
          r.active && e();
        });
      } }, { key: "inertiaTick", value: function() {
        var e, r, n, o, l, c, p, h = this, g = this.interaction, d = _t(g).resistance, b = (g._now() - this.t0) / 1e3;
        if (b < this.te) {
          var w, I = 1 - (Math.exp(-d * b) - this.lambda_v0) / this.one_ve_v0;
          this.isModified ? (e = 0, r = 0, n = this.targetOffset.x, o = this.targetOffset.y, l = this.modifiedOffset.x, c = this.modifiedOffset.y, w = { x: xn(p = I, e, n, l), y: xn(p, r, o, c) }) : w = { x: this.targetOffset.x * I, y: this.targetOffset.y * I };
          var E = { x: w.x - this.currentOffset.x, y: w.y - this.currentOffset.y };
          this.currentOffset.x += E.x, this.currentOffset.y += E.y, g.offsetBy(E), g.move(), this.onNextFrame(function() {
            return h.inertiaTick();
          });
        } else g.offsetBy({ x: this.modifiedOffset.x - this.currentOffset.x, y: this.modifiedOffset.y - this.currentOffset.y }), this.end();
      } }, { key: "smoothEndTick", value: function() {
        var e = this, r = this.interaction, n = r._now() - this.t0, o = _t(r).smoothEndDuration;
        if (n < o) {
          var l = { x: On(n, 0, this.targetOffset.x, o), y: On(n, 0, this.targetOffset.y, o) }, c = { x: l.x - this.currentOffset.x, y: l.y - this.currentOffset.y };
          this.currentOffset.x += c.x, this.currentOffset.y += c.y, r.offsetBy(c), r.move({ skipModifiers: this.modifierCount }), this.onNextFrame(function() {
            return e.smoothEndTick();
          });
        } else r.offsetBy({ x: this.targetOffset.x - this.currentOffset.x, y: this.targetOffset.y - this.currentOffset.y }), this.end();
      } }, { key: "resume", value: function(e) {
        var r = e.pointer, n = e.event, o = e.eventTarget, l = this.interaction;
        l.offsetBy({ x: -this.currentOffset.x, y: -this.currentOffset.y }), l.updatePointer(r, n, o, !0), l._doPhase({ interaction: l, event: n, phase: "resume" }), yt(l.coords.prev, l.coords.cur), this.stop();
      } }, { key: "end", value: function() {
        this.interaction.move(), this.interaction.end(), this.stop();
      } }, { key: "stop", value: function() {
        this.active = this.smoothEnd = !1, this.interaction.simulation = null, Re.cancel(this.timeout);
      } }]), t;
    }();
    function _t(t) {
      var e = t.interactable, r = t.prepared;
      return e && e.options && r.name && e.options[r.name].inertia;
    }
    var ko = { id: "inertia", before: ["modifiers", "actions"], install: function(t) {
      var e = t.defaults;
      t.usePlugin(Sn), t.usePlugin(mn), t.actions.phases.inertiastart = !0, t.actions.phases.resume = !0, e.perAction.inertia = { enabled: !1, resistance: 10, minSpeed: 100, endSpeed: 10, allowResume: !0, smoothEndDuration: 300 };
    }, listeners: { "interactions:new": function(t) {
      var e = t.interaction;
      e.inertia = new $o(e);
    }, "interactions:before-action-end": function(t) {
      var e = t.interaction, r = t.event;
      return (!e._interacting || e.simulation || !e.inertia.start(r)) && null;
    }, "interactions:down": function(t) {
      var e = t.interaction, r = t.eventTarget, n = e.inertia;
      if (n.active) for (var o = r; S.element(o); ) {
        if (o === e.element) {
          n.resume(t);
          break;
        }
        o = G(o);
      }
    }, "interactions:stop": function(t) {
      var e = t.interaction.inertia;
      e.active && e.stop();
    }, "interactions:before-action-resume": function(t) {
      var e = t.interaction.modification;
      e.stop(t), e.start(t, t.interaction.coords.cur.page), e.applyToInteraction(t);
    }, "interactions:before-action-inertiastart": function(t) {
      return t.interaction.modification.setAndApply(t);
    }, "interactions:action-resume": ut, "interactions:action-inertiastart": ut, "interactions:after-action-inertiastart": function(t) {
      return t.interaction.modification.restoreInteractionCoords(t);
    }, "interactions:after-action-resume": function(t) {
      return t.interaction.modification.restoreInteractionCoords(t);
    } } };
    function xn(t, e, r, n) {
      var o = 1 - t;
      return o * o * e + 2 * o * t * r + t * t * n;
    }
    function On(t, e, r, n) {
      return -r * (t /= n) * (t - 2) + e;
    }
    var zo = ko;
    function _n(t, e) {
      for (var r = 0; r < e.length; r++) {
        var n = e[r];
        if (t.immediatePropagationStopped) break;
        n(t);
      }
    }
    var Mn = function() {
      function t(e) {
        v(this, t), this.options = void 0, this.types = {}, this.propagationStopped = !1, this.immediatePropagationStopped = !1, this.global = void 0, this.options = F({}, e || {});
      }
      return y(t, [{ key: "fire", value: function(e) {
        var r, n = this.global;
        (r = this.types[e.type]) && _n(e, r), !e.propagationStopped && n && (r = n[e.type]) && _n(e, r);
      } }, { key: "on", value: function(e, r) {
        var n = Ue(e, r);
        for (e in n) this.types[e] = en(this.types[e] || [], n[e]);
      } }, { key: "off", value: function(e, r) {
        var n = Ue(e, r);
        for (e in n) {
          var o = this.types[e];
          if (o && o.length) for (var l = 0, c = n[e]; l < c.length; l++) {
            var p = c[l], h = o.indexOf(p);
            h !== -1 && o.splice(h, 1);
          }
        }
      } }, { key: "getRect", value: function(e) {
        return null;
      } }]), t;
    }(), Ro = function() {
      function t(e) {
        v(this, t), this.currentTarget = void 0, this.originalEvent = void 0, this.type = void 0, this.originalEvent = e, bt(this, e);
      }
      return y(t, [{ key: "preventOriginalDefault", value: function() {
        this.originalEvent.preventDefault();
      } }, { key: "stopPropagation", value: function() {
        this.originalEvent.stopPropagation();
      } }, { key: "stopImmediatePropagation", value: function() {
        this.originalEvent.stopImmediatePropagation();
      } }]), t;
    }();
    function pt(t) {
      return S.object(t) ? { capture: !!t.capture, passive: !!t.passive } : { capture: !!t, passive: !1 };
    }
    function Mt(t, e) {
      return t === e || (typeof t == "boolean" ? !!e.capture === t && !e.passive : !!t.capture == !!e.capture && !!t.passive == !!e.passive);
    }
    var jo = { id: "events", install: function(t) {
      var e, r = [], n = {}, o = [], l = { add: c, remove: p, addDelegate: function(d, b, w, I, E) {
        var D = pt(E);
        if (!n[w]) {
          n[w] = [];
          for (var L = 0; L < o.length; L++) {
            var j = o[L];
            c(j, w, h), c(j, w, g, !0);
          }
        }
        var N = n[w], q = lt(N, function(Q) {
          return Q.selector === d && Q.context === b;
        });
        q || (q = { selector: d, context: b, listeners: [] }, N.push(q)), q.listeners.push({ func: I, options: D });
      }, removeDelegate: function(d, b, w, I, E) {
        var D, L = pt(E), j = n[w], N = !1;
        if (j)
          for (D = j.length - 1; D >= 0; D--) {
            var q = j[D];
            if (q.selector === d && q.context === b) {
              for (var Q = q.listeners, B = Q.length - 1; B >= 0; B--) {
                var Z = Q[B];
                if (Z.func === I && Mt(Z.options, L)) {
                  Q.splice(B, 1), Q.length || (j.splice(D, 1), p(b, w, h), p(b, w, g, !0)), N = !0;
                  break;
                }
              }
              if (N) break;
            }
          }
      }, delegateListener: h, delegateUseCapture: g, delegatedEvents: n, documents: o, targets: r, supportsOptions: !1, supportsPassive: !1 };
      function c(d, b, w, I) {
        if (d.addEventListener) {
          var E = pt(I), D = lt(r, function(L) {
            return L.eventTarget === d;
          });
          D || (D = { eventTarget: d, events: {} }, r.push(D)), D.events[b] || (D.events[b] = []), lt(D.events[b], function(L) {
            return L.func === w && Mt(L.options, E);
          }) || (d.addEventListener(b, w, l.supportsOptions ? E : E.capture), D.events[b].push({ func: w, options: E }));
        }
      }
      function p(d, b, w, I) {
        if (d.addEventListener && d.removeEventListener) {
          var E = at(r, function(me) {
            return me.eventTarget === d;
          }), D = r[E];
          if (D && D.events) if (b !== "all") {
            var L = !1, j = D.events[b];
            if (j) {
              if (w === "all") {
                for (var N = j.length - 1; N >= 0; N--) {
                  var q = j[N];
                  p(d, b, q.func, q.options);
                }
                return;
              }
              for (var Q = pt(I), B = 0; B < j.length; B++) {
                var Z = j[B];
                if (Z.func === w && Mt(Z.options, Q)) {
                  d.removeEventListener(b, w, l.supportsOptions ? Q : Q.capture), j.splice(B, 1), j.length === 0 && (delete D.events[b], L = !0);
                  break;
                }
              }
            }
            L && !Object.keys(D.events).length && r.splice(E, 1);
          } else for (b in D.events) D.events.hasOwnProperty(b) && p(d, b, "all");
        }
      }
      function h(d, b) {
        for (var w = pt(b), I = new Ro(d), E = n[d.type], D = Qr(d)[0], L = D; S.element(L); ) {
          for (var j = 0; j < E.length; j++) {
            var N = E[j], q = N.selector, Q = N.context;
            if (K(L, q) && U(Q, D) && U(Q, L)) {
              var B = N.listeners;
              I.currentTarget = L;
              for (var Z = 0; Z < B.length; Z++) {
                var me = B[Z];
                Mt(me.options, w) && me.func(I);
              }
            }
          }
          L = G(L);
        }
      }
      function g(d) {
        return h(d, !0);
      }
      return (e = t.document) == null || e.createElement("div").addEventListener("test", null, { get capture() {
        return l.supportsOptions = !0;
      }, get passive() {
        return l.supportsPassive = !0;
      } }), t.events = l, l;
    } }, ur = { methodOrder: ["simulationResume", "mouseOrPen", "hasPointer", "idle"], search: function(t) {
      for (var e = 0, r = ur.methodOrder; e < r.length; e++) {
        var n = r[e], o = ur[n](t);
        if (o) return o;
      }
      return null;
    }, simulationResume: function(t) {
      var e = t.pointerType, r = t.eventType, n = t.eventTarget, o = t.scope;
      if (!/down|start/i.test(r)) return null;
      for (var l = 0, c = o.interactions.list; l < c.length; l++) {
        var p = c[l], h = n;
        if (p.simulation && p.simulation.allowResume && p.pointerType === e) for (; h; ) {
          if (h === p.element) return p;
          h = G(h);
        }
      }
      return null;
    }, mouseOrPen: function(t) {
      var e, r = t.pointerId, n = t.pointerType, o = t.eventType, l = t.scope;
      if (n !== "mouse" && n !== "pen") return null;
      for (var c = 0, p = l.interactions.list; c < p.length; c++) {
        var h = p[c];
        if (h.pointerType === n) {
          if (h.simulation && !Cn(h, r)) continue;
          if (h.interacting()) return h;
          e || (e = h);
        }
      }
      if (e) return e;
      for (var g = 0, d = l.interactions.list; g < d.length; g++) {
        var b = d[g];
        if (!(b.pointerType !== n || /down/i.test(o) && b.simulation)) return b;
      }
      return null;
    }, hasPointer: function(t) {
      for (var e = t.pointerId, r = 0, n = t.scope.interactions.list; r < n.length; r++) {
        var o = n[r];
        if (Cn(o, e)) return o;
      }
      return null;
    }, idle: function(t) {
      for (var e = t.pointerType, r = 0, n = t.scope.interactions.list; r < n.length; r++) {
        var o = n[r];
        if (o.pointers.length === 1) {
          var l = o.interactable;
          if (l && (!l.options.gesture || !l.options.gesture.enabled)) continue;
        } else if (o.pointers.length >= 2) continue;
        if (!o.interacting() && e === o.pointerType) return o;
      }
      return null;
    } };
    function Cn(t, e) {
      return t.pointers.some(function(r) {
        return r.id === e;
      });
    }
    var Ao = ur, pr = ["pointerDown", "pointerMove", "pointerUp", "updatePointer", "removePointer", "windowBlur"];
    function En(t, e) {
      return function(r) {
        var n = e.interactions.list, o = Jr(r), l = Qr(r), c = l[0], p = l[1], h = [];
        if (/^touch/.test(r.type)) {
          e.prevTouchTime = e.now();
          for (var g = 0, d = r.changedTouches; g < d.length; g++) {
            var b = d[g], w = { pointer: b, pointerId: st(b), pointerType: o, eventType: r.type, eventTarget: c, curEventTarget: p, scope: e }, I = In(w);
            h.push([w.pointer, w.eventTarget, w.curEventTarget, I]);
          }
        } else {
          var E = !1;
          if (!$.supportsPointerEvent && /mouse/.test(r.type)) {
            for (var D = 0; D < n.length && !E; D++) E = n[D].pointerType !== "mouse" && n[D].pointerIsDown;
            E = E || e.now() - e.prevTouchTime < 500 || r.timeStamp === 0;
          }
          if (!E) {
            var L = { pointer: r, pointerId: st(r), pointerType: o, eventType: r.type, curEventTarget: p, eventTarget: c, scope: e }, j = In(L);
            h.push([L.pointer, L.eventTarget, L.curEventTarget, j]);
          }
        }
        for (var N = 0; N < h.length; N++) {
          var q = h[N], Q = q[0], B = q[1], Z = q[2];
          q[3][t](Q, r, B, Z);
        }
      };
    }
    function In(t) {
      var e = t.pointerType, r = t.scope, n = { interaction: Ao.search(t), searchDetails: t };
      return r.fire("interactions:find", n), n.interaction || r.interactions.new({ pointerType: e });
    }
    function hr(t, e) {
      var r = t.doc, n = t.scope, o = t.options, l = n.interactions.docEvents, c = n.events, p = c[e];
      for (var h in n.browser.isIOS && !o.events && (o.events = { passive: !1 }), c.delegatedEvents) p(r, h, c.delegateListener), p(r, h, c.delegateUseCapture, !0);
      for (var g = o && o.events, d = 0; d < l.length; d++) {
        var b = l[d];
        p(r, b.type, b.listener, g);
      }
    }
    var Lo = { id: "core/interactions", install: function(t) {
      for (var e = {}, r = 0; r < pr.length; r++) {
        var n = pr[r];
        e[n] = En(n, t);
      }
      var o, l = $.pEventTypes;
      function c() {
        for (var p = 0, h = t.interactions.list; p < h.length; p++) {
          var g = h[p];
          if (g.pointerIsDown && g.pointerType === "touch" && !g._interacting) for (var d = function() {
            var I = w[b];
            t.documents.some(function(E) {
              return U(E.doc, I.downTarget);
            }) || g.removePointer(I.pointer, I.event);
          }, b = 0, w = g.pointers; b < w.length; b++) d();
        }
      }
      (o = W.PointerEvent ? [{ type: l.down, listener: c }, { type: l.down, listener: e.pointerDown }, { type: l.move, listener: e.pointerMove }, { type: l.up, listener: e.pointerUp }, { type: l.cancel, listener: e.pointerUp }] : [{ type: "mousedown", listener: e.pointerDown }, { type: "mousemove", listener: e.pointerMove }, { type: "mouseup", listener: e.pointerUp }, { type: "touchstart", listener: c }, { type: "touchstart", listener: e.pointerDown }, { type: "touchmove", listener: e.pointerMove }, { type: "touchend", listener: e.pointerUp }, { type: "touchcancel", listener: e.pointerUp }]).push({ type: "blur", listener: function(p) {
        for (var h = 0, g = t.interactions.list; h < g.length; h++)
          g[h].documentBlur(p);
      } }), t.prevTouchTime = 0, t.Interaction = function(p) {
        O(g, p);
        var h = C(g);
        function g() {
          return v(this, g), h.apply(this, arguments);
        }
        return y(g, [{ key: "pointerMoveTolerance", get: function() {
          return t.interactions.pointerMoveTolerance;
        }, set: function(d) {
          t.interactions.pointerMoveTolerance = d;
        } }, { key: "_now", value: function() {
          return t.now();
        } }]), g;
      }(Io), t.interactions = { list: [], new: function(p) {
        p.scopeFire = function(g, d) {
          return t.fire(g, d);
        };
        var h = new t.Interaction(p);
        return t.interactions.list.push(h), h;
      }, listeners: e, docEvents: o, pointerMoveTolerance: 1 }, t.usePlugin(gn);
    }, listeners: { "scope:add-document": function(t) {
      return hr(t, "add");
    }, "scope:remove-document": function(t) {
      return hr(t, "remove");
    }, "interactable:unset": function(t, e) {
      for (var r = t.interactable, n = e.interactions.list.length - 1; n >= 0; n--) {
        var o = e.interactions.list[n];
        o.interactable === r && (o.stop(), e.fire("interactions:destroy", { interaction: o }), o.destroy(), e.interactions.list.length > 2 && e.interactions.list.splice(n, 1));
      }
    } }, onDocSignal: hr, doOnInteractions: En, methodNames: pr }, Ho = Lo, Ae = function(t) {
      return t[t.On = 0] = "On", t[t.Off = 1] = "Off", t;
    }(Ae || {}), Fo = function() {
      function t(e, r, n, o) {
        v(this, t), this.target = void 0, this.options = void 0, this._actions = void 0, this.events = new Mn(), this._context = void 0, this._win = void 0, this._doc = void 0, this._scopeEvents = void 0, this._actions = r.actions, this.target = e, this._context = r.context || n, this._win = te(ke(e) ? this._context : e), this._doc = this._win.document, this._scopeEvents = o, this.set(r);
      }
      return y(t, [{ key: "_defaults", get: function() {
        return { base: {}, perAction: {}, actions: {} };
      } }, { key: "setOnEvents", value: function(e, r) {
        return S.func(r.onstart) && this.on("".concat(e, "start"), r.onstart), S.func(r.onmove) && this.on("".concat(e, "move"), r.onmove), S.func(r.onend) && this.on("".concat(e, "end"), r.onend), S.func(r.oninertiastart) && this.on("".concat(e, "inertiastart"), r.oninertiastart), this;
      } }, { key: "updatePerActionListeners", value: function(e, r, n) {
        var o, l = this, c = (o = this._actions.map[e]) == null ? void 0 : o.filterEventType, p = function(h) {
          return (c == null || c(h)) && xt(h, l._actions);
        };
        (S.array(r) || S.object(r)) && this._onOff(Ae.Off, e, r, void 0, p), (S.array(n) || S.object(n)) && this._onOff(Ae.On, e, n, void 0, p);
      } }, { key: "setPerAction", value: function(e, r) {
        var n = this._defaults;
        for (var o in r) {
          var l = o, c = this.options[e], p = r[l];
          l === "listeners" && this.updatePerActionListeners(e, c.listeners, p), S.array(p) ? c[l] = tn(p) : S.plainObject(p) ? (c[l] = F(c[l] || {}, Ve(p)), S.object(n.perAction[l]) && "enabled" in n.perAction[l] && (c[l].enabled = p.enabled !== !1)) : S.bool(p) && S.object(n.perAction[l]) ? c[l].enabled = p : c[l] = p;
        }
      } }, { key: "getRect", value: function(e) {
        return e = e || (S.element(this.target) ? this.target : null), S.string(this.target) && (e = e || this._context.querySelector(this.target)), Oe(e);
      } }, { key: "rectChecker", value: function(e) {
        var r = this;
        return S.func(e) ? (this.getRect = function(n) {
          var o = F({}, e.apply(r, n));
          return "width" in o || (o.width = o.right - o.left, o.height = o.bottom - o.top), o;
        }, this) : e === null ? (delete this.getRect, this) : this.getRect;
      } }, { key: "_backCompatOption", value: function(e, r) {
        if (ke(r) || S.object(r)) {
          for (var n in this.options[e] = r, this._actions.map) this.options[n][e] = r;
          return this;
        }
        return this.options[e];
      } }, { key: "origin", value: function(e) {
        return this._backCompatOption("origin", e);
      } }, { key: "deltaSource", value: function(e) {
        return e === "page" || e === "client" ? (this.options.deltaSource = e, this) : this.options.deltaSource;
      } }, { key: "getAllElements", value: function() {
        var e = this.target;
        return S.string(e) ? Array.from(this._context.querySelectorAll(e)) : S.func(e) && e.getAllElements ? e.getAllElements() : S.element(e) ? [e] : [];
      } }, { key: "context", value: function() {
        return this._context;
      } }, { key: "inContext", value: function(e) {
        return this._context === e.ownerDocument || U(this._context, e);
      } }, { key: "testIgnoreAllow", value: function(e, r, n) {
        return !this.testIgnore(e.ignoreFrom, r, n) && this.testAllow(e.allowFrom, r, n);
      } }, { key: "testAllow", value: function(e, r, n) {
        return !e || !!S.element(n) && (S.string(e) ? pe(n, e, r) : !!S.element(e) && U(e, n));
      } }, { key: "testIgnore", value: function(e, r, n) {
        return !(!e || !S.element(n)) && (S.string(e) ? pe(n, e, r) : !!S.element(e) && U(e, n));
      } }, { key: "fire", value: function(e) {
        return this.events.fire(e), this;
      } }, { key: "_onOff", value: function(e, r, n, o, l) {
        S.object(r) && !S.array(r) && (o = n, n = null);
        var c = Ue(r, n, l);
        for (var p in c) {
          p === "wheel" && (p = $.wheelEvent);
          for (var h = 0, g = c[p]; h < g.length; h++) {
            var d = g[h];
            xt(p, this._actions) ? this.events[e === Ae.On ? "on" : "off"](p, d) : S.string(this.target) ? this._scopeEvents[e === Ae.On ? "addDelegate" : "removeDelegate"](this.target, this._context, p, d, o) : this._scopeEvents[e === Ae.On ? "add" : "remove"](this.target, p, d, o);
          }
        }
        return this;
      } }, { key: "on", value: function(e, r, n) {
        return this._onOff(Ae.On, e, r, n);
      } }, { key: "off", value: function(e, r, n) {
        return this._onOff(Ae.Off, e, r, n);
      } }, { key: "set", value: function(e) {
        var r = this._defaults;
        for (var n in S.object(e) || (e = {}), this.options = Ve(r.base), this._actions.methodDict) {
          var o = n, l = this._actions.methodDict[o];
          this.options[o] = {}, this.setPerAction(o, F(F({}, r.perAction), r.actions[o])), this[l](e[o]);
        }
        for (var c in e) c !== "getRect" ? S.func(this[c]) && this[c](e[c]) : this.rectChecker(e.getRect);
        return this;
      } }, { key: "unset", value: function() {
        if (S.string(this.target)) for (var e in this._scopeEvents.delegatedEvents) for (var r = this._scopeEvents.delegatedEvents[e], n = r.length - 1; n >= 0; n--) {
          var o = r[n], l = o.selector, c = o.context, p = o.listeners;
          l === this.target && c === this._context && r.splice(n, 1);
          for (var h = p.length - 1; h >= 0; h--) this._scopeEvents.removeDelegate(this.target, this._context, e, p[h][0], p[h][1]);
        }
        else this._scopeEvents.remove(this.target, "all");
      } }]), t;
    }(), Wo = function() {
      function t(e) {
        var r = this;
        v(this, t), this.list = [], this.selectorMap = {}, this.scope = void 0, this.scope = e, e.addListeners({ "interactable:unset": function(n) {
          var o = n.interactable, l = o.target, c = S.string(l) ? r.selectorMap[l] : l[r.scope.id], p = at(c, function(h) {
            return h === o;
          });
          c.splice(p, 1);
        } });
      }
      return y(t, [{ key: "new", value: function(e, r) {
        r = F(r || {}, { actions: this.scope.actions });
        var n = new this.scope.Interactable(e, r, this.scope.document, this.scope.events);
        return this.scope.addDocument(n._doc), this.list.push(n), S.string(e) ? (this.selectorMap[e] || (this.selectorMap[e] = []), this.selectorMap[e].push(n)) : (n.target[this.scope.id] || Object.defineProperty(e, this.scope.id, { value: [], configurable: !0 }), e[this.scope.id].push(n)), this.scope.fire("interactable:new", { target: e, options: r, interactable: n, win: this.scope._win }), n;
      } }, { key: "getExisting", value: function(e, r) {
        var n = r && r.context || this.scope.document, o = S.string(e), l = o ? this.selectorMap[e] : e[this.scope.id];
        if (l) return lt(l, function(c) {
          return c._context === n && (o || c.inContext(e));
        });
      } }, { key: "forEachMatch", value: function(e, r) {
        for (var n = 0, o = this.list; n < o.length; n++) {
          var l = o[n], c = void 0;
          if ((S.string(l.target) ? S.element(e) && K(e, l.target) : e === l.target) && l.inContext(e) && (c = r(l)), c !== void 0) return c;
        }
      } }]), t;
    }(), Uo = function() {
      function t() {
        var e = this;
        v(this, t), this.id = "__interact_scope_".concat(Math.floor(100 * Math.random())), this.isInitialized = !1, this.listenerMaps = [], this.browser = $, this.defaults = Ve(bn), this.Eventable = Mn, this.actions = { map: {}, phases: { start: !0, move: !0, end: !0 }, methodDict: {}, phaselessTypes: {} }, this.interactStatic = function(n) {
          var o = function l(c, p) {
            var h = n.interactables.getExisting(c, p);
            return h || ((h = n.interactables.new(c, p)).events.global = l.globalEvents), h;
          };
          return o.getPointerAverage = Zr, o.getTouchBBox = Vt, o.getTouchDistance = qt, o.getTouchAngle = Zt, o.getElementRect = Oe, o.getElementClientRect = ve, o.matchesSelector = K, o.closest = A, o.globalEvents = {}, o.version = "1.10.27", o.scope = n, o.use = function(l, c) {
            return this.scope.usePlugin(l, c), this;
          }, o.isSet = function(l, c) {
            return !!this.scope.interactables.get(l, c && c.context);
          }, o.on = ct(function(l, c, p) {
            if (S.string(l) && l.search(" ") !== -1 && (l = l.trim().split(/ +/)), S.array(l)) {
              for (var h = 0, g = l; h < g.length; h++) {
                var d = g[h];
                this.on(d, c, p);
              }
              return this;
            }
            if (S.object(l)) {
              for (var b in l) this.on(b, l[b], c);
              return this;
            }
            return xt(l, this.scope.actions) ? this.globalEvents[l] ? this.globalEvents[l].push(c) : this.globalEvents[l] = [c] : this.scope.events.add(this.scope.document, l, c, { options: p }), this;
          }, "The interact.on() method is being deprecated"), o.off = ct(function(l, c, p) {
            if (S.string(l) && l.search(" ") !== -1 && (l = l.trim().split(/ +/)), S.array(l)) {
              for (var h = 0, g = l; h < g.length; h++) {
                var d = g[h];
                this.off(d, c, p);
              }
              return this;
            }
            if (S.object(l)) {
              for (var b in l) this.off(b, l[b], c);
              return this;
            }
            var w;
            return xt(l, this.scope.actions) ? l in this.globalEvents && (w = this.globalEvents[l].indexOf(c)) !== -1 && this.globalEvents[l].splice(w, 1) : this.scope.events.remove(this.scope.document, l, c, p), this;
          }, "The interact.off() method is being deprecated"), o.debug = function() {
            return this.scope;
          }, o.supportsTouch = function() {
            return $.supportsTouch;
          }, o.supportsPointerEvent = function() {
            return $.supportsPointerEvent;
          }, o.stop = function() {
            for (var l = 0, c = this.scope.interactions.list; l < c.length; l++) c[l].stop();
            return this;
          }, o.pointerMoveTolerance = function(l) {
            return S.number(l) ? (this.scope.interactions.pointerMoveTolerance = l, this) : this.scope.interactions.pointerMoveTolerance;
          }, o.addDocument = function(l, c) {
            this.scope.addDocument(l, c);
          }, o.removeDocument = function(l) {
            this.scope.removeDocument(l);
          }, o;
        }(this), this.InteractEvent = lr, this.Interactable = void 0, this.interactables = new Wo(this), this._win = void 0, this.document = void 0, this.window = void 0, this.documents = [], this._plugins = { list: [], map: {} }, this.onWindowUnload = function(n) {
          return e.removeDocument(n.target);
        };
        var r = this;
        this.Interactable = function(n) {
          O(l, n);
          var o = C(l);
          function l() {
            return v(this, l), o.apply(this, arguments);
          }
          return y(l, [{ key: "_defaults", get: function() {
            return r.defaults;
          } }, { key: "set", value: function(c) {
            return M(k(l.prototype), "set", this).call(this, c), r.fire("interactable:set", { options: c, interactable: this }), this;
          } }, { key: "unset", value: function() {
            M(k(l.prototype), "unset", this).call(this);
            var c = r.interactables.list.indexOf(this);
            c < 0 || (r.interactables.list.splice(c, 1), r.fire("interactable:unset", { interactable: this }));
          } }]), l;
        }(Fo);
      }
      return y(t, [{ key: "addListeners", value: function(e, r) {
        this.listenerMaps.push({ id: r, map: e });
      } }, { key: "fire", value: function(e, r) {
        for (var n = 0, o = this.listenerMaps; n < o.length; n++) {
          var l = o[n].map[e];
          if (l && l(r, this, e) === !1) return !1;
        }
      } }, { key: "init", value: function(e) {
        return this.isInitialized ? this : function(r, n) {
          return r.isInitialized = !0, S.window(n) && ee(n), W.init(n), $.init(n), Re.init(n), r.window = n, r.document = n.document, r.usePlugin(Ho), r.usePlugin(jo), r;
        }(this, e);
      } }, { key: "pluginIsInstalled", value: function(e) {
        var r = e.id;
        return r ? !!this._plugins.map[r] : this._plugins.list.indexOf(e) !== -1;
      } }, { key: "usePlugin", value: function(e, r) {
        if (!this.isInitialized) return this;
        if (this.pluginIsInstalled(e)) return this;
        if (e.id && (this._plugins.map[e.id] = e), this._plugins.list.push(e), e.install && e.install(this, r), e.listeners && e.before) {
          for (var n = 0, o = this.listenerMaps.length, l = e.before.reduce(function(p, h) {
            return p[h] = !0, p[Pn(h)] = !0, p;
          }, {}); n < o; n++) {
            var c = this.listenerMaps[n].id;
            if (c && (l[c] || l[Pn(c)])) break;
          }
          this.listenerMaps.splice(n, 0, { id: e.id, map: e.listeners });
        } else e.listeners && this.listenerMaps.push({ id: e.id, map: e.listeners });
        return this;
      } }, { key: "addDocument", value: function(e, r) {
        if (this.getDocIndex(e) !== -1) return !1;
        var n = te(e);
        r = r ? F({}, r) : {}, this.documents.push({ doc: e, options: r }), this.events.documents.push(e), e !== this.document && this.events.add(n, "unload", this.onWindowUnload), this.fire("scope:add-document", { doc: e, window: n, scope: this, options: r });
      } }, { key: "removeDocument", value: function(e) {
        var r = this.getDocIndex(e), n = te(e), o = this.documents[r].options;
        this.events.remove(n, "unload", this.onWindowUnload), this.documents.splice(r, 1), this.events.documents.splice(r, 1), this.fire("scope:remove-document", { doc: e, window: n, scope: this, options: o });
      } }, { key: "getDocIndex", value: function(e) {
        for (var r = 0; r < this.documents.length; r++) if (this.documents[r].doc === e) return r;
        return -1;
      } }, { key: "getDocOptions", value: function(e) {
        var r = this.getDocIndex(e);
        return r === -1 ? null : this.documents[r].options;
      } }, { key: "now", value: function() {
        return (this.window.Date || Date).now();
      } }]), t;
    }();
    function Pn(t) {
      return t && t.replace(/\/.*$/, "");
    }
    var Dn = new Uo(), ge = Dn.interactStatic, No = typeof globalThis < "u" ? globalThis : window;
    Dn.init(No);
    var Yo = Object.freeze({ __proto__: null, edgeTarget: function() {
    }, elements: function() {
    }, grid: function(t) {
      var e = [["x", "y"], ["left", "top"], ["right", "bottom"], ["width", "height"]].filter(function(n) {
        var o = n[0], l = n[1];
        return o in t || l in t;
      }), r = function(n, o) {
        for (var l = t.range, c = t.limits, p = c === void 0 ? { left: -1 / 0, right: 1 / 0, top: -1 / 0, bottom: 1 / 0 } : c, h = t.offset, g = h === void 0 ? { x: 0, y: 0 } : h, d = { range: l, grid: t, x: null, y: null }, b = 0; b < e.length; b++) {
          var w = e[b], I = w[0], E = w[1], D = Math.round((n - g.x) / t[I]), L = Math.round((o - g.y) / t[E]);
          d[I] = Math.max(p.left, Math.min(p.right, D * t[I] + g.x)), d[E] = Math.max(p.top, Math.min(p.bottom, L * t[E] + g.y));
        }
        return d;
      };
      return r.grid = t, r.coordFields = e, r;
    } }), Go = { id: "snappers", install: function(t) {
      var e = t.interactStatic;
      e.snappers = F(e.snappers || {}, Yo), e.createSnapGrid = e.snappers.grid;
    } }, Ko = Go, Xo = { start: function(t) {
      var e = t.state, r = t.rect, n = t.edges, o = t.pageCoords, l = e.options, c = l.ratio, p = l.enabled, h = e.options, g = h.equalDelta, d = h.modifiers;
      c === "preserve" && (c = r.width / r.height), e.startCoords = F({}, o), e.startRect = F({}, r), e.ratio = c, e.equalDelta = g;
      var b = e.linkedEdges = { top: n.top || n.left && !n.bottom, left: n.left || n.top && !n.right, bottom: n.bottom || n.right && !n.top, right: n.right || n.bottom && !n.left };
      if (e.xIsPrimaryAxis = !(!n.left && !n.right), e.equalDelta) {
        var w = (b.left ? 1 : -1) * (b.top ? 1 : -1);
        e.edgeSign = { x: w, y: w };
      } else e.edgeSign = { x: b.left ? -1 : 1, y: b.top ? -1 : 1 };
      if (p !== !1 && F(n, b), d != null && d.length) {
        var I = new ar(t.interaction);
        I.copyFrom(t.interaction.modification), I.prepareStates(d), e.subModification = I, I.startAll(u({}, t));
      }
    }, set: function(t) {
      var e = t.state, r = t.rect, n = t.coords, o = e.linkedEdges, l = F({}, n), c = e.equalDelta ? Bo : Vo;
      if (F(t.edges, o), c(e, e.xIsPrimaryAxis, n, r), !e.subModification) return null;
      var p = F({}, r);
      mt(o, p, { x: n.x - l.x, y: n.y - l.y });
      var h = e.subModification.setAll(u(u({}, t), {}, { rect: p, edges: o, pageCoords: n, prevCoords: n, prevRect: p })), g = h.delta;
      return h.changed && (c(e, Math.abs(g.x) > Math.abs(g.y), h.coords, h.rect), F(n, h.coords)), h.eventProps;
    }, defaults: { ratio: "preserve", equalDelta: !1, modifiers: [], enabled: !1 } };
    function Bo(t, e, r) {
      var n = t.startCoords, o = t.edgeSign;
      e ? r.y = n.y + (r.x - n.x) * o.y : r.x = n.x + (r.y - n.y) * o.x;
    }
    function Vo(t, e, r, n) {
      var o = t.startRect, l = t.startCoords, c = t.ratio, p = t.edgeSign;
      if (e) {
        var h = n.width / c;
        r.y = l.y + (h - o.height) * p.y;
      } else {
        var g = n.height * c;
        r.x = l.x + (g - o.width) * p.x;
      }
    }
    var qo = je(Xo, "aspectRatio"), $n = function() {
    };
    $n._defaults = {};
    var Ct = $n;
    function Ye(t, e, r) {
      return S.func(t) ? ye(t, e.interactable, e.element, [r.x, r.y, e]) : ye(t, e.interactable, e.element);
    }
    var Et = { start: function(t) {
      var e = t.rect, r = t.startOffset, n = t.state, o = t.interaction, l = t.pageCoords, c = n.options, p = c.elementRect, h = F({ left: 0, top: 0, right: 0, bottom: 0 }, c.offset || {});
      if (e && p) {
        var g = Ye(c.restriction, o, l);
        if (g) {
          var d = g.right - g.left - e.width, b = g.bottom - g.top - e.height;
          d < 0 && (h.left += d, h.right += d), b < 0 && (h.top += b, h.bottom += b);
        }
        h.left += r.left - e.width * p.left, h.top += r.top - e.height * p.top, h.right += r.right - e.width * (1 - p.right), h.bottom += r.bottom - e.height * (1 - p.bottom);
      }
      n.offset = h;
    }, set: function(t) {
      var e = t.coords, r = t.interaction, n = t.state, o = n.options, l = n.offset, c = Ye(o.restriction, r, e);
      if (c) {
        var p = function(h) {
          return !h || "left" in h && "top" in h || ((h = F({}, h)).left = h.x || 0, h.top = h.y || 0, h.right = h.right || h.left + h.width, h.bottom = h.bottom || h.top + h.height), h;
        }(c);
        e.x = Math.max(Math.min(p.right - l.right, e.x), p.left + l.left), e.y = Math.max(Math.min(p.bottom - l.bottom, e.y), p.top + l.top);
      }
    }, defaults: { restriction: null, elementRect: null, offset: null, endOnly: !1, enabled: !1 } }, Zo = je(Et, "restrict"), kn = { top: 1 / 0, left: 1 / 0, bottom: -1 / 0, right: -1 / 0 }, zn = { top: -1 / 0, left: -1 / 0, bottom: 1 / 0, right: 1 / 0 };
    function Rn(t, e) {
      for (var r = 0, n = ["top", "left", "bottom", "right"]; r < n.length; r++) {
        var o = n[r];
        o in t || (t[o] = e[o]);
      }
      return t;
    }
    var ht = { noInner: kn, noOuter: zn, start: function(t) {
      var e, r = t.interaction, n = t.startOffset, o = t.state, l = o.options;
      l && (e = Me(Ye(l.offset, r, r.coords.start.page))), e = e || { x: 0, y: 0 }, o.offset = { top: e.y + n.top, left: e.x + n.left, bottom: e.y - n.bottom, right: e.x - n.right };
    }, set: function(t) {
      var e = t.coords, r = t.edges, n = t.interaction, o = t.state, l = o.offset, c = o.options;
      if (r) {
        var p = F({}, e), h = Ye(c.inner, n, p) || {}, g = Ye(c.outer, n, p) || {};
        Rn(h, kn), Rn(g, zn), r.top ? e.y = Math.min(Math.max(g.top + l.top, p.y), h.top + l.top) : r.bottom && (e.y = Math.max(Math.min(g.bottom + l.bottom, p.y), h.bottom + l.bottom)), r.left ? e.x = Math.min(Math.max(g.left + l.left, p.x), h.left + l.left) : r.right && (e.x = Math.max(Math.min(g.right + l.right, p.x), h.right + l.right));
      }
    }, defaults: { inner: null, outer: null, offset: null, endOnly: !1, enabled: !1 } }, Jo = je(ht, "restrictEdges"), Qo = F({ get elementRect() {
      return { top: 0, left: 0, bottom: 1, right: 1 };
    }, set elementRect(t) {
    } }, Et.defaults), es = je({ start: Et.start, set: Et.set, defaults: Qo }, "restrictRect"), ts = { width: -1 / 0, height: -1 / 0 }, rs = { width: 1 / 0, height: 1 / 0 }, ns = je({ start: function(t) {
      return ht.start(t);
    }, set: function(t) {
      var e = t.interaction, r = t.state, n = t.rect, o = t.edges, l = r.options;
      if (o) {
        var c = ze(Ye(l.min, e, t.coords)) || ts, p = ze(Ye(l.max, e, t.coords)) || rs;
        r.options = { endOnly: l.endOnly, inner: F({}, ht.noInner), outer: F({}, ht.noOuter) }, o.top ? (r.options.inner.top = n.bottom - c.height, r.options.outer.top = n.bottom - p.height) : o.bottom && (r.options.inner.bottom = n.top + c.height, r.options.outer.bottom = n.top + p.height), o.left ? (r.options.inner.left = n.right - c.width, r.options.outer.left = n.right - p.width) : o.right && (r.options.inner.right = n.left + c.width, r.options.outer.right = n.left + p.width), ht.set(t), r.options = l;
      }
    }, defaults: { min: null, max: null, endOnly: !1, enabled: !1 } }, "restrictSize"), dr = { start: function(t) {
      var e, r = t.interaction, n = t.interactable, o = t.element, l = t.rect, c = t.state, p = t.startOffset, h = c.options, g = h.offsetWithOrigin ? function(w) {
        var I = w.interaction.element, E = Me(ye(w.state.options.origin, null, null, [I])), D = E || it(w.interactable, I, w.interaction.prepared.name);
        return D;
      }(t) : { x: 0, y: 0 };
      if (h.offset === "startCoords") e = { x: r.coords.start.page.x, y: r.coords.start.page.y };
      else {
        var d = ye(h.offset, n, o, [r]);
        (e = Me(d) || { x: 0, y: 0 }).x += g.x, e.y += g.y;
      }
      var b = h.relativePoints;
      c.offsets = l && b && b.length ? b.map(function(w, I) {
        return { index: I, relativePoint: w, x: p.left - l.width * w.x + e.x, y: p.top - l.height * w.y + e.y };
      }) : [{ index: 0, relativePoint: null, x: e.x, y: e.y }];
    }, set: function(t) {
      var e = t.interaction, r = t.coords, n = t.state, o = n.options, l = n.offsets, c = it(e.interactable, e.element, e.prepared.name), p = F({}, r), h = [];
      o.offsetWithOrigin || (p.x -= c.x, p.y -= c.y);
      for (var g = 0, d = l; g < d.length; g++) for (var b = d[g], w = p.x - b.x, I = p.y - b.y, E = 0, D = o.targets.length; E < D; E++) {
        var L = o.targets[E], j = void 0;
        (j = S.func(L) ? L(w, I, e._proxy, b, E) : L) && h.push({ x: (S.number(j.x) ? j.x : w) + b.x, y: (S.number(j.y) ? j.y : I) + b.y, range: S.number(j.range) ? j.range : o.range, source: L, index: E, offset: b });
      }
      for (var N = { target: null, inRange: !1, distance: 0, range: 0, delta: { x: 0, y: 0 } }, q = 0; q < h.length; q++) {
        var Q = h[q], B = Q.range, Z = Q.x - p.x, me = Q.y - p.y, le = ot(Z, me), Te = le <= B;
        B === 1 / 0 && N.inRange && N.range !== 1 / 0 && (Te = !1), N.target && !(Te ? N.inRange && B !== 1 / 0 ? le / B < N.distance / N.range : B === 1 / 0 && N.range !== 1 / 0 || le < N.distance : !N.inRange && le < N.distance) || (N.target = Q, N.distance = le, N.range = B, N.inRange = Te, N.delta.x = Z, N.delta.y = me);
      }
      return N.inRange && (r.x = N.target.x, r.y = N.target.y), n.closest = N, N;
    }, defaults: { range: 1 / 0, targets: null, offset: null, offsetWithOrigin: !0, origin: null, relativePoints: null, endOnly: !1, enabled: !1 } }, is = je(dr, "snap"), It = { start: function(t) {
      var e = t.state, r = t.edges, n = e.options;
      if (!r) return null;
      t.state = { options: { targets: null, relativePoints: [{ x: r.left ? 0 : 1, y: r.top ? 0 : 1 }], offset: n.offset || "self", origin: { x: 0, y: 0 }, range: n.range } }, e.targetFields = e.targetFields || [["width", "height"], ["x", "y"]], dr.start(t), e.offsets = t.state.offsets, t.state = e;
    }, set: function(t) {
      var e = t.interaction, r = t.state, n = t.coords, o = r.options, l = r.offsets, c = { x: n.x - l[0].x, y: n.y - l[0].y };
      r.options = F({}, o), r.options.targets = [];
      for (var p = 0, h = o.targets || []; p < h.length; p++) {
        var g = h[p], d = void 0;
        if (d = S.func(g) ? g(c.x, c.y, e) : g) {
          for (var b = 0, w = r.targetFields; b < w.length; b++) {
            var I = w[b], E = I[0], D = I[1];
            if (E in d || D in d) {
              d.x = d[E], d.y = d[D];
              break;
            }
          }
          r.options.targets.push(d);
        }
      }
      var L = dr.set(t);
      return r.options = o, L;
    }, defaults: { range: 1 / 0, targets: null, offset: null, endOnly: !1, enabled: !1 } }, os = je(It, "snapSize"), fr = { aspectRatio: qo, restrictEdges: Jo, restrict: Zo, restrictRect: es, restrictSize: ns, snapEdges: je({ start: function(t) {
      var e = t.edges;
      return e ? (t.state.targetFields = t.state.targetFields || [[e.left ? "left" : "right", e.top ? "top" : "bottom"]], It.start(t)) : null;
    }, set: It.set, defaults: F(Ve(It.defaults), { targets: void 0, range: void 0, offset: { x: 0, y: 0 } }) }, "snapEdges"), snap: is, snapSize: os, spring: Ct, avoid: Ct, transform: Ct, rubberband: Ct }, ss = { id: "modifiers", install: function(t) {
      var e = t.interactStatic;
      for (var r in t.usePlugin(mn), t.usePlugin(Ko), e.modifiers = fr, fr) {
        var n = fr[r], o = n._defaults, l = n._methods;
        o._methods = l, t.defaults.perAction[r] = o;
      }
    } }, as = ss, jn = function(t) {
      O(r, t);
      var e = C(r);
      function r(n, o, l, c, p, h) {
        var g;
        if (v(this, r), bt(T(g = e.call(this, p)), l), l !== o && bt(T(g), o), g.timeStamp = h, g.originalEvent = l, g.type = n, g.pointerId = st(o), g.pointerType = Jr(o), g.target = c, g.currentTarget = null, n === "tap") {
          var d = p.getPointerIndex(o);
          g.dt = g.timeStamp - p.pointers[d].downTime;
          var b = g.timeStamp - p.tapTime;
          g.double = !!p.prevTap && p.prevTap.type !== "doubletap" && p.prevTap.target === g.target && b < 500;
        } else n === "doubletap" && (g.dt = o.timeStamp - p.tapTime, g.double = !0);
        return g;
      }
      return y(r, [{ key: "_subtractOrigin", value: function(n) {
        var o = n.x, l = n.y;
        return this.pageX -= o, this.pageY -= l, this.clientX -= o, this.clientY -= l, this;
      } }, { key: "_addOrigin", value: function(n) {
        var o = n.x, l = n.y;
        return this.pageX += o, this.pageY += l, this.clientX += o, this.clientY += l, this;
      } }, { key: "preventDefault", value: function() {
        this.originalEvent.preventDefault();
      } }]), r;
    }(wt), dt = { id: "pointer-events/base", before: ["inertia", "modifiers", "auto-start", "actions"], install: function(t) {
      t.pointerEvents = dt, t.defaults.actions.pointerEvents = dt.defaults, F(t.actions.phaselessTypes, dt.types);
    }, listeners: { "interactions:new": function(t) {
      var e = t.interaction;
      e.prevTap = null, e.tapTime = 0;
    }, "interactions:update-pointer": function(t) {
      var e = t.down, r = t.pointerInfo;
      !e && r.hold || (r.hold = { duration: 1 / 0, timeout: null });
    }, "interactions:move": function(t, e) {
      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget;
      t.duplicate || r.pointerIsDown && !r.pointerWasMoved || (r.pointerIsDown && vr(t), Le({ interaction: r, pointer: n, event: o, eventTarget: l, type: "move" }, e));
    }, "interactions:down": function(t, e) {
      (function(r, n) {
        for (var o = r.interaction, l = r.pointer, c = r.event, p = r.eventTarget, h = r.pointerIndex, g = o.pointers[h].hold, d = _e(p), b = { interaction: o, pointer: l, event: c, eventTarget: p, type: "hold", targets: [], path: d, node: null }, w = 0; w < d.length; w++) {
          var I = d[w];
          b.node = I, n.fire("pointerEvents:collect-targets", b);
        }
        if (b.targets.length) {
          for (var E = 1 / 0, D = 0, L = b.targets; D < L.length; D++) {
            var j = L[D].eventable.options.holdDuration;
            j < E && (E = j);
          }
          g.duration = E, g.timeout = setTimeout(function() {
            Le({ interaction: o, eventTarget: p, pointer: l, event: c, type: "hold" }, n);
          }, E);
        }
      })(t, e), Le(t, e);
    }, "interactions:up": function(t, e) {
      vr(t), Le(t, e), function(r, n) {
        var o = r.interaction, l = r.pointer, c = r.event, p = r.eventTarget;
        o.pointerWasMoved || Le({ interaction: o, eventTarget: p, pointer: l, event: c, type: "tap" }, n);
      }(t, e);
    }, "interactions:cancel": function(t, e) {
      vr(t), Le(t, e);
    } }, PointerEvent: jn, fire: Le, collectEventTargets: An, defaults: { holdDuration: 600, ignoreFrom: null, allowFrom: null, origin: { x: 0, y: 0 } }, types: { down: !0, move: !0, up: !0, cancel: !0, tap: !0, doubletap: !0, hold: !0 } };
    function Le(t, e) {
      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget, c = t.type, p = t.targets, h = p === void 0 ? An(t, e) : p, g = new jn(c, n, o, l, r, e.now());
      e.fire("pointerEvents:new", { pointerEvent: g });
      for (var d = { interaction: r, pointer: n, event: o, eventTarget: l, targets: h, type: c, pointerEvent: g }, b = 0; b < h.length; b++) {
        var w = h[b];
        for (var I in w.props || {}) g[I] = w.props[I];
        var E = it(w.eventable, w.node);
        if (g._subtractOrigin(E), g.eventable = w.eventable, g.currentTarget = w.node, w.eventable.fire(g), g._addOrigin(E), g.immediatePropagationStopped || g.propagationStopped && b + 1 < h.length && h[b + 1].node !== g.currentTarget) break;
      }
      if (e.fire("pointerEvents:fired", d), c === "tap") {
        var D = g.double ? Le({ interaction: r, pointer: n, event: o, eventTarget: l, type: "doubletap" }, e) : g;
        r.prevTap = D, r.tapTime = D.timeStamp;
      }
      return g;
    }
    function An(t, e) {
      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget, c = t.type, p = r.getPointerIndex(n), h = r.pointers[p];
      if (c === "tap" && (r.pointerWasMoved || !h || h.downTarget !== l)) return [];
      for (var g = _e(l), d = { interaction: r, pointer: n, event: o, eventTarget: l, type: c, path: g, targets: [], node: null }, b = 0; b < g.length; b++) {
        var w = g[b];
        d.node = w, e.fire("pointerEvents:collect-targets", d);
      }
      return c === "hold" && (d.targets = d.targets.filter(function(I) {
        var E, D;
        return I.eventable.options.holdDuration === ((E = r.pointers[p]) == null || (D = E.hold) == null ? void 0 : D.duration);
      })), d.targets;
    }
    function vr(t) {
      var e = t.interaction, r = t.pointerIndex, n = e.pointers[r].hold;
      n && n.timeout && (clearTimeout(n.timeout), n.timeout = null);
    }
    var ls = Object.freeze({ __proto__: null, default: dt });
    function cs(t) {
      var e = t.interaction;
      e.holdIntervalHandle && (clearInterval(e.holdIntervalHandle), e.holdIntervalHandle = null);
    }
    var us = { id: "pointer-events/holdRepeat", install: function(t) {
      t.usePlugin(dt);
      var e = t.pointerEvents;
      e.defaults.holdRepeatInterval = 0, e.types.holdrepeat = t.actions.phaselessTypes.holdrepeat = !0;
    }, listeners: ["move", "up", "cancel", "endall"].reduce(function(t, e) {
      return t["pointerEvents:".concat(e)] = cs, t;
    }, { "pointerEvents:new": function(t) {
      var e = t.pointerEvent;
      e.type === "hold" && (e.count = (e.count || 0) + 1);
    }, "pointerEvents:fired": function(t, e) {
      var r = t.interaction, n = t.pointerEvent, o = t.eventTarget, l = t.targets;
      if (n.type === "hold" && l.length) {
        var c = l[0].eventable.options.holdRepeatInterval;
        c <= 0 || (r.holdIntervalHandle = setTimeout(function() {
          e.pointerEvents.fire({ interaction: r, eventTarget: o, type: "hold", pointer: n, event: n }, e);
        }, c));
      }
    } }) }, ps = us, hs = { id: "pointer-events/interactableTargets", install: function(t) {
      var e = t.Interactable;
      e.prototype.pointerEvents = function(n) {
        return F(this.events.options, n), this;
      };
      var r = e.prototype._backCompatOption;
      e.prototype._backCompatOption = function(n, o) {
        var l = r.call(this, n, o);
        return l === this && (this.events.options[n] = o), l;
      };
    }, listeners: { "pointerEvents:collect-targets": function(t, e) {
      var r = t.targets, n = t.node, o = t.type, l = t.eventTarget;
      e.interactables.forEachMatch(n, function(c) {
        var p = c.events, h = p.options;
        p.types[o] && p.types[o].length && c.testIgnoreAllow(h, n, l) && r.push({ node: n, eventable: p, props: { interactable: c } });
      });
    }, "interactable:new": function(t) {
      var e = t.interactable;
      e.events.getRect = function(r) {
        return e.getRect(r);
      };
    }, "interactable:set": function(t, e) {
      var r = t.interactable, n = t.options;
      F(r.events.options, e.pointerEvents.defaults), F(r.events.options, n.pointerEvents || {});
    } } }, ds = hs, fs = { id: "pointer-events", install: function(t) {
      t.usePlugin(ls), t.usePlugin(ps), t.usePlugin(ds);
    } }, vs = fs, gs = { id: "reflow", install: function(t) {
      var e = t.Interactable;
      t.actions.phases.reflow = !0, e.prototype.reflow = function(r) {
        return function(n, o, l) {
          for (var c = n.getAllElements(), p = l.window.Promise, h = p ? [] : null, g = function() {
            var b = c[d], w = n.getRect(b);
            if (!w) return 1;
            var I, E = lt(l.interactions.list, function(j) {
              return j.interacting() && j.interactable === n && j.element === b && j.prepared.name === o.name;
            });
            if (E) E.move(), h && (I = E._reflowPromise || new p(function(j) {
              E._reflowResolve = j;
            }));
            else {
              var D = ze(w), L = /* @__PURE__ */ function(j) {
                return { coords: j, get page() {
                  return this.coords.page;
                }, get client() {
                  return this.coords.client;
                }, get timeStamp() {
                  return this.coords.timeStamp;
                }, get pageX() {
                  return this.coords.page.x;
                }, get pageY() {
                  return this.coords.page.y;
                }, get clientX() {
                  return this.coords.client.x;
                }, get clientY() {
                  return this.coords.client.y;
                }, get pointerId() {
                  return this.coords.pointerId;
                }, get target() {
                  return this.coords.target;
                }, get type() {
                  return this.coords.type;
                }, get pointerType() {
                  return this.coords.pointerType;
                }, get buttons() {
                  return this.coords.buttons;
                }, preventDefault: function() {
                } };
              }({ page: { x: D.x, y: D.y }, client: { x: D.x, y: D.y }, timeStamp: l.now() });
              I = function(j, N, q, Q, B) {
                var Z = j.interactions.new({ pointerType: "reflow" }), me = { interaction: Z, event: B, pointer: B, eventTarget: q, phase: "reflow" };
                Z.interactable = N, Z.element = q, Z.prevEvent = B, Z.updatePointer(B, B, q, !0), Br(Z.coords.delta), nr(Z.prepared, Q), Z._doPhase(me);
                var le = j.window, Te = le.Promise, Se = Te ? new Te(function(Pe) {
                  Z._reflowResolve = Pe;
                }) : void 0;
                return Z._reflowPromise = Se, Z.start(Q, N, q), Z._interacting ? (Z.move(me), Z.end(B)) : (Z.stop(), Z._reflowResolve()), Z.removePointer(B, B), Se;
              }(l, n, b, o, L);
            }
            h && h.push(I);
          }, d = 0; d < c.length && !g(); d++) ;
          return h && p.all(h).then(function() {
            return n;
          });
        }(this, r, t);
      };
    }, listeners: { "interactions:stop": function(t, e) {
      var r = t.interaction;
      r.pointerType === "reflow" && (r._reflowResolve && r._reflowResolve(), function(n, o) {
        n.splice(n.indexOf(o), 1);
      }(e.interactions.list, r));
    } } }, ms = gs;
    if (ge.use(gn), ge.use(Sn), ge.use(vs), ge.use(zo), ge.use(as), ge.use(So), ge.use(uo), ge.use(ho), ge.use(ms), ge.default = ge, f(a) === "object" && a) try {
      a.exports = ge;
    } catch {
    }
    return ge.default = ge, ge;
  });
})(Rt, Rt.exports);
var Ts = Rt.exports;
const gr = /* @__PURE__ */ Ze(Ts);
var wi = { exports: {} };
(function(a, i) {
  (function(s, u) {
    a.exports = u();
  })(Fe, function() {
    var s = 1e3, u = 6e4, f = 36e5, v = "millisecond", m = "second", y = "minute", x = "hour", O = "day", k = "week", P = "month", T = "quarter", C = "year", M = "date", _ = "Invalid Date", z = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, X = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, Y = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(W) {
      var R = ["th", "st", "nd", "rd"], $ = W % 100;
      return "[" + W + (R[($ - 20) % 10] || R[$] || R[0]) + "]";
    } }, ee = function(W, R, $) {
      var U = String(W);
      return !U || U.length >= R ? W : "" + Array(R + 1 - U.length).join($) + W;
    }, te = { s: ee, z: function(W) {
      var R = -W.utcOffset(), $ = Math.abs(R), U = Math.floor($ / 60), A = $ % 60;
      return (R <= 0 ? "+" : "-") + ee(U, 2, "0") + ":" + ee(A, 2, "0");
    }, m: function W(R, $) {
      if (R.date() < $.date()) return -W($, R);
      var U = 12 * ($.year() - R.year()) + ($.month() - R.month()), A = R.clone().add(U, P), G = $ - A < 0, K = R.clone().add(U + (G ? -1 : 1), P);
      return +(-(U + ($ - A) / (G ? A - K : K - A)) || 0);
    }, a: function(W) {
      return W < 0 ? Math.ceil(W) || 0 : Math.floor(W);
    }, p: function(W) {
      return { M: P, y: C, w: k, d: O, D: M, h: x, m: y, s: m, ms: v, Q: T }[W] || String(W || "").toLowerCase().replace(/s$/, "");
    }, u: function(W) {
      return W === void 0;
    } }, ne = "en", ue = {};
    ue[ne] = Y;
    var S = "$isDayjsObject", be = function(W) {
      return W instanceof de || !(!W || !W[S]);
    }, we = function W(R, $, U) {
      var A;
      if (!R) return ne;
      if (typeof R == "string") {
        var G = R.toLowerCase();
        ue[G] && (A = G), $ && (ue[G] = $, A = G);
        var K = R.split("-");
        if (!A && K.length > 1) return W(K[0]);
      } else {
        var ie = R.name;
        ue[ie] = R, A = ie;
      }
      return !U && A && (ne = A), A || !U && ne;
    }, ce = function(W, R) {
      if (be(W)) return W.clone();
      var $ = typeof R == "object" ? R : {};
      return $.date = W, $.args = arguments, new de($);
    }, re = te;
    re.l = we, re.i = be, re.w = function(W, R) {
      return ce(W, { locale: R.$L, utc: R.$u, x: R.$x, $offset: R.$offset });
    };
    var de = function() {
      function W($) {
        this.$L = we($.locale, null, !0), this.parse($), this.$x = this.$x || $.x || {}, this[S] = !0;
      }
      var R = W.prototype;
      return R.parse = function($) {
        this.$d = function(U) {
          var A = U.date, G = U.utc;
          if (A === null) return /* @__PURE__ */ new Date(NaN);
          if (re.u(A)) return /* @__PURE__ */ new Date();
          if (A instanceof Date) return new Date(A);
          if (typeof A == "string" && !/Z$/i.test(A)) {
            var K = A.match(z);
            if (K) {
              var ie = K[2] - 1 || 0, ae = (K[7] || "0").substring(0, 3);
              return G ? new Date(Date.UTC(K[1], ie, K[3] || 1, K[4] || 0, K[5] || 0, K[6] || 0, ae)) : new Date(K[1], ie, K[3] || 1, K[4] || 0, K[5] || 0, K[6] || 0, ae);
            }
          }
          return new Date(A);
        }($), this.init();
      }, R.init = function() {
        var $ = this.$d;
        this.$y = $.getFullYear(), this.$M = $.getMonth(), this.$D = $.getDate(), this.$W = $.getDay(), this.$H = $.getHours(), this.$m = $.getMinutes(), this.$s = $.getSeconds(), this.$ms = $.getMilliseconds();
      }, R.$utils = function() {
        return re;
      }, R.isValid = function() {
        return this.$d.toString() !== _;
      }, R.isSame = function($, U) {
        var A = ce($);
        return this.startOf(U) <= A && A <= this.endOf(U);
      }, R.isAfter = function($, U) {
        return ce($) < this.startOf(U);
      }, R.isBefore = function($, U) {
        return this.endOf(U) < ce($);
      }, R.$g = function($, U, A) {
        return re.u($) ? this[U] : this.set(A, $);
      }, R.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, R.valueOf = function() {
        return this.$d.getTime();
      }, R.startOf = function($, U) {
        var A = this, G = !!re.u(U) || U, K = re.p($), ie = function(F, fe) {
          var ye = re.w(A.$u ? Date.UTC(A.$y, fe, F) : new Date(A.$y, fe, F), A);
          return G ? ye : ye.endOf(O);
        }, ae = function(F, fe) {
          return re.w(A.toDate()[F].apply(A.toDate("s"), (G ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(fe)), A);
        }, pe = this.$W, he = this.$M, ve = this.$D, Oe = "set" + (this.$u ? "UTC" : "");
        switch (K) {
          case C:
            return G ? ie(1, 0) : ie(31, 11);
          case P:
            return G ? ie(1, he) : ie(0, he + 1);
          case k:
            var _e = this.$locale().weekStart || 0, ke = (pe < _e ? pe + 7 : pe) - _e;
            return ie(G ? ve - ke : ve + (6 - ke), he);
          case O:
          case M:
            return ae(Oe + "Hours", 0);
          case x:
            return ae(Oe + "Minutes", 1);
          case y:
            return ae(Oe + "Seconds", 2);
          case m:
            return ae(Oe + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, R.endOf = function($) {
        return this.startOf($, !1);
      }, R.$set = function($, U) {
        var A, G = re.p($), K = "set" + (this.$u ? "UTC" : ""), ie = (A = {}, A[O] = K + "Date", A[M] = K + "Date", A[P] = K + "Month", A[C] = K + "FullYear", A[x] = K + "Hours", A[y] = K + "Minutes", A[m] = K + "Seconds", A[v] = K + "Milliseconds", A)[G], ae = G === O ? this.$D + (U - this.$W) : U;
        if (G === P || G === C) {
          var pe = this.clone().set(M, 1);
          pe.$d[ie](ae), pe.init(), this.$d = pe.set(M, Math.min(this.$D, pe.daysInMonth())).$d;
        } else ie && this.$d[ie](ae);
        return this.init(), this;
      }, R.set = function($, U) {
        return this.clone().$set($, U);
      }, R.get = function($) {
        return this[re.p($)]();
      }, R.add = function($, U) {
        var A, G = this;
        $ = Number($);
        var K = re.p(U), ie = function(he) {
          var ve = ce(G);
          return re.w(ve.date(ve.date() + Math.round(he * $)), G);
        };
        if (K === P) return this.set(P, this.$M + $);
        if (K === C) return this.set(C, this.$y + $);
        if (K === O) return ie(1);
        if (K === k) return ie(7);
        var ae = (A = {}, A[y] = u, A[x] = f, A[m] = s, A)[K] || 1, pe = this.$d.getTime() + $ * ae;
        return re.w(pe, this);
      }, R.subtract = function($, U) {
        return this.add(-1 * $, U);
      }, R.format = function($) {
        var U = this, A = this.$locale();
        if (!this.isValid()) return A.invalidDate || _;
        var G = $ || "YYYY-MM-DDTHH:mm:ssZ", K = re.z(this), ie = this.$H, ae = this.$m, pe = this.$M, he = A.weekdays, ve = A.months, Oe = A.meridiem, _e = function(fe, ye, Me, ze) {
          return fe && (fe[ye] || fe(U, G)) || Me[ye].slice(0, ze);
        }, ke = function(fe) {
          return re.s(ie % 12 || 12, fe, "0");
        }, F = Oe || function(fe, ye, Me) {
          var ze = fe < 12 ? "AM" : "PM";
          return Me ? ze.toLowerCase() : ze;
        };
        return G.replace(X, function(fe, ye) {
          return ye || function(Me) {
            switch (Me) {
              case "YY":
                return String(U.$y).slice(-2);
              case "YYYY":
                return re.s(U.$y, 4, "0");
              case "M":
                return pe + 1;
              case "MM":
                return re.s(pe + 1, 2, "0");
              case "MMM":
                return _e(A.monthsShort, pe, ve, 3);
              case "MMMM":
                return _e(ve, pe);
              case "D":
                return U.$D;
              case "DD":
                return re.s(U.$D, 2, "0");
              case "d":
                return String(U.$W);
              case "dd":
                return _e(A.weekdaysMin, U.$W, he, 2);
              case "ddd":
                return _e(A.weekdaysShort, U.$W, he, 3);
              case "dddd":
                return he[U.$W];
              case "H":
                return String(ie);
              case "HH":
                return re.s(ie, 2, "0");
              case "h":
                return ke(1);
              case "hh":
                return ke(2);
              case "a":
                return F(ie, ae, !0);
              case "A":
                return F(ie, ae, !1);
              case "m":
                return String(ae);
              case "mm":
                return re.s(ae, 2, "0");
              case "s":
                return String(U.$s);
              case "ss":
                return re.s(U.$s, 2, "0");
              case "SSS":
                return re.s(U.$ms, 3, "0");
              case "Z":
                return K;
            }
            return null;
          }(fe) || K.replace(":", "");
        });
      }, R.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, R.diff = function($, U, A) {
        var G, K = this, ie = re.p(U), ae = ce($), pe = (ae.utcOffset() - this.utcOffset()) * u, he = this - ae, ve = function() {
          return re.m(K, ae);
        };
        switch (ie) {
          case C:
            G = ve() / 12;
            break;
          case P:
            G = ve();
            break;
          case T:
            G = ve() / 3;
            break;
          case k:
            G = (he - pe) / 6048e5;
            break;
          case O:
            G = (he - pe) / 864e5;
            break;
          case x:
            G = he / f;
            break;
          case y:
            G = he / u;
            break;
          case m:
            G = he / s;
            break;
          default:
            G = he;
        }
        return A ? G : re.a(G);
      }, R.daysInMonth = function() {
        return this.endOf(P).$D;
      }, R.$locale = function() {
        return ue[this.$L];
      }, R.locale = function($, U) {
        if (!$) return this.$L;
        var A = this.clone(), G = we($, U, !0);
        return G && (A.$L = G), A;
      }, R.clone = function() {
        return re.w(this.$d, this);
      }, R.toDate = function() {
        return new Date(this.valueOf());
      }, R.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, R.toISOString = function() {
        return this.$d.toISOString();
      }, R.toString = function() {
        return this.$d.toUTCString();
      }, W;
    }(), Ce = de.prototype;
    return ce.prototype = Ce, [["$ms", v], ["$s", m], ["$m", y], ["$H", x], ["$W", O], ["$M", P], ["$y", C], ["$D", M]].forEach(function(W) {
      Ce[W[1]] = function(R) {
        return this.$g(R, W[0], W[1]);
      };
    }), ce.extend = function(W, R) {
      return W.$i || (W(R, de, ce), W.$i = !0), ce;
    }, ce.locale = we, ce.isDayjs = be, ce.unix = function(W) {
      return ce(1e3 * W);
    }, ce.en = ue[ne], ce.Ls = ue, ce.p = {}, ce;
  });
})(wi);
var ws = wi.exports;
const De = /* @__PURE__ */ Ze(ws);
var Si = { exports: {} };
(function(a, i) {
  (function(s, u) {
    a.exports = u();
  })(Fe, function() {
    var s = "minute", u = /[+-]\d\d(?::?\d\d)?/g, f = /([+-]|\d\d)/g;
    return function(v, m, y) {
      var x = m.prototype;
      y.utc = function(_) {
        var z = { date: _, utc: !0, args: arguments };
        return new m(z);
      }, x.utc = function(_) {
        var z = y(this.toDate(), { locale: this.$L, utc: !0 });
        return _ ? z.add(this.utcOffset(), s) : z;
      }, x.local = function() {
        return y(this.toDate(), { locale: this.$L, utc: !1 });
      };
      var O = x.parse;
      x.parse = function(_) {
        _.utc && (this.$u = !0), this.$utils().u(_.$offset) || (this.$offset = _.$offset), O.call(this, _);
      };
      var k = x.init;
      x.init = function() {
        if (this.$u) {
          var _ = this.$d;
          this.$y = _.getUTCFullYear(), this.$M = _.getUTCMonth(), this.$D = _.getUTCDate(), this.$W = _.getUTCDay(), this.$H = _.getUTCHours(), this.$m = _.getUTCMinutes(), this.$s = _.getUTCSeconds(), this.$ms = _.getUTCMilliseconds();
        } else k.call(this);
      };
      var P = x.utcOffset;
      x.utcOffset = function(_, z) {
        var X = this.$utils().u;
        if (X(_)) return this.$u ? 0 : X(this.$offset) ? P.call(this) : this.$offset;
        if (typeof _ == "string" && (_ = function(ne) {
          ne === void 0 && (ne = "");
          var ue = ne.match(u);
          if (!ue) return null;
          var S = ("" + ue[0]).match(f) || ["-", 0, 0], be = S[0], we = 60 * +S[1] + +S[2];
          return we === 0 ? 0 : be === "+" ? we : -we;
        }(_), _ === null)) return this;
        var Y = Math.abs(_) <= 16 ? 60 * _ : _, ee = this;
        if (z) return ee.$offset = Y, ee.$u = _ === 0, ee;
        if (_ !== 0) {
          var te = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          (ee = this.local().add(Y + te, s)).$offset = Y, ee.$x.$localOffset = te;
        } else ee = this.utc();
        return ee;
      };
      var T = x.format;
      x.format = function(_) {
        var z = _ || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return T.call(this, z);
      }, x.valueOf = function() {
        var _ = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
        return this.$d.valueOf() - 6e4 * _;
      }, x.isUTC = function() {
        return !!this.$u;
      }, x.toISOString = function() {
        return this.toDate().toISOString();
      }, x.toString = function() {
        return this.toDate().toUTCString();
      };
      var C = x.toDate;
      x.toDate = function(_) {
        return _ === "s" && this.$offset ? y(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : C.call(this);
      };
      var M = x.diff;
      x.diff = function(_, z, X) {
        if (_ && this.$u === _.$u) return M.call(this, _, z, X);
        var Y = this.local(), ee = y(_).local();
        return M.call(Y, ee, z, X);
      };
    };
  });
})(Si);
var Ss = Si.exports;
const xs = /* @__PURE__ */ Ze(Ss);
function Os() {
  this.__data__ = [], this.size = 0;
}
var _s = Os;
function Ms(a, i) {
  return a === i || a !== a && i !== i;
}
var xi = Ms, Cs = xi;
function Es(a, i) {
  for (var s = a.length; s--; )
    if (Cs(a[s][0], i))
      return s;
  return -1;
}
var Ft = Es, Is = Ft, Ps = Array.prototype, Ds = Ps.splice;
function $s(a) {
  var i = this.__data__, s = Is(i, a);
  if (s < 0)
    return !1;
  var u = i.length - 1;
  return s == u ? i.pop() : Ds.call(i, s, 1), --this.size, !0;
}
var ks = $s, zs = Ft;
function Rs(a) {
  var i = this.__data__, s = zs(i, a);
  return s < 0 ? void 0 : i[s][1];
}
var js = Rs, As = Ft;
function Ls(a) {
  return As(this.__data__, a) > -1;
}
var Hs = Ls, Fs = Ft;
function Ws(a, i) {
  var s = this.__data__, u = Fs(s, a);
  return u < 0 ? (++this.size, s.push([a, i])) : s[u][1] = i, this;
}
var Us = Ws, Ns = _s, Ys = ks, Gs = js, Ks = Hs, Xs = Us;
function Je(a) {
  var i = -1, s = a == null ? 0 : a.length;
  for (this.clear(); ++i < s; ) {
    var u = a[i];
    this.set(u[0], u[1]);
  }
}
Je.prototype.clear = Ns;
Je.prototype.delete = Ys;
Je.prototype.get = Gs;
Je.prototype.has = Ks;
Je.prototype.set = Xs;
var Wt = Je, Bs = Wt;
function Vs() {
  this.__data__ = new Bs(), this.size = 0;
}
var qs = Vs;
function Zs(a) {
  var i = this.__data__, s = i.delete(a);
  return this.size = i.size, s;
}
var Js = Zs;
function Qs(a) {
  return this.__data__.get(a);
}
var ea = Qs;
function ta(a) {
  return this.__data__.has(a);
}
var ra = ta, na = typeof Fe == "object" && Fe && Fe.Object === Object && Fe, Oi = na, ia = Oi, oa = typeof self == "object" && self && self.Object === Object && self, sa = ia || oa || Function("return this")(), $e = sa, aa = $e, la = aa.Symbol, kr = la, Ln = kr, _i = Object.prototype, ca = _i.hasOwnProperty, ua = _i.toString, vt = Ln ? Ln.toStringTag : void 0;
function pa(a) {
  var i = ca.call(a, vt), s = a[vt];
  try {
    a[vt] = void 0;
    var u = !0;
  } catch {
  }
  var f = ua.call(a);
  return u && (i ? a[vt] = s : delete a[vt]), f;
}
var ha = pa, da = Object.prototype, fa = da.toString;
function va(a) {
  return fa.call(a);
}
var ga = va, Hn = kr, ma = ha, ba = ga, ya = "[object Null]", Ta = "[object Undefined]", Fn = Hn ? Hn.toStringTag : void 0;
function wa(a) {
  return a == null ? a === void 0 ? Ta : ya : Fn && Fn in Object(a) ? ma(a) : ba(a);
}
var Ut = wa;
function Sa(a) {
  var i = typeof a;
  return a != null && (i == "object" || i == "function");
}
var Mi = Sa, xa = Ut, Oa = Mi, _a = "[object AsyncFunction]", Ma = "[object Function]", Ca = "[object GeneratorFunction]", Ea = "[object Proxy]";
function Ia(a) {
  if (!Oa(a))
    return !1;
  var i = xa(a);
  return i == Ma || i == Ca || i == _a || i == Ea;
}
var Ci = Ia, Pa = $e, Da = Pa["__core-js_shared__"], $a = Da, mr = $a, Wn = function() {
  var a = /[^.]+$/.exec(mr && mr.keys && mr.keys.IE_PROTO || "");
  return a ? "Symbol(src)_1." + a : "";
}();
function ka(a) {
  return !!Wn && Wn in a;
}
var za = ka, Ra = Function.prototype, ja = Ra.toString;
function Aa(a) {
  if (a != null) {
    try {
      return ja.call(a);
    } catch {
    }
    try {
      return a + "";
    } catch {
    }
  }
  return "";
}
var Ei = Aa, La = Ci, Ha = za, Fa = Mi, Wa = Ei, Ua = /[\\^$.*+?()[\]{}|]/g, Na = /^\[object .+?Constructor\]$/, Ya = Function.prototype, Ga = Object.prototype, Ka = Ya.toString, Xa = Ga.hasOwnProperty, Ba = RegExp(
  "^" + Ka.call(Xa).replace(Ua, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Va(a) {
  if (!Fa(a) || Ha(a))
    return !1;
  var i = La(a) ? Ba : Na;
  return i.test(Wa(a));
}
var qa = Va;
function Za(a, i) {
  return a == null ? void 0 : a[i];
}
var Ja = Za, Qa = qa, el = Ja;
function tl(a, i) {
  var s = el(a, i);
  return Qa(s) ? s : void 0;
}
var Qe = tl, rl = Qe, nl = $e, il = rl(nl, "Map"), zr = il, ol = Qe, sl = ol(Object, "create"), Nt = sl, Un = Nt;
function al() {
  this.__data__ = Un ? Un(null) : {}, this.size = 0;
}
var ll = al;
function cl(a) {
  var i = this.has(a) && delete this.__data__[a];
  return this.size -= i ? 1 : 0, i;
}
var ul = cl, pl = Nt, hl = "__lodash_hash_undefined__", dl = Object.prototype, fl = dl.hasOwnProperty;
function vl(a) {
  var i = this.__data__;
  if (pl) {
    var s = i[a];
    return s === hl ? void 0 : s;
  }
  return fl.call(i, a) ? i[a] : void 0;
}
var gl = vl, ml = Nt, bl = Object.prototype, yl = bl.hasOwnProperty;
function Tl(a) {
  var i = this.__data__;
  return ml ? i[a] !== void 0 : yl.call(i, a);
}
var wl = Tl, Sl = Nt, xl = "__lodash_hash_undefined__";
function Ol(a, i) {
  var s = this.__data__;
  return this.size += this.has(a) ? 0 : 1, s[a] = Sl && i === void 0 ? xl : i, this;
}
var _l = Ol, Ml = ll, Cl = ul, El = gl, Il = wl, Pl = _l;
function et(a) {
  var i = -1, s = a == null ? 0 : a.length;
  for (this.clear(); ++i < s; ) {
    var u = a[i];
    this.set(u[0], u[1]);
  }
}
et.prototype.clear = Ml;
et.prototype.delete = Cl;
et.prototype.get = El;
et.prototype.has = Il;
et.prototype.set = Pl;
var Dl = et, Nn = Dl, $l = Wt, kl = zr;
function zl() {
  this.size = 0, this.__data__ = {
    hash: new Nn(),
    map: new (kl || $l)(),
    string: new Nn()
  };
}
var Rl = zl;
function jl(a) {
  var i = typeof a;
  return i == "string" || i == "number" || i == "symbol" || i == "boolean" ? a !== "__proto__" : a === null;
}
var Al = jl, Ll = Al;
function Hl(a, i) {
  var s = a.__data__;
  return Ll(i) ? s[typeof i == "string" ? "string" : "hash"] : s.map;
}
var Yt = Hl, Fl = Yt;
function Wl(a) {
  var i = Fl(this, a).delete(a);
  return this.size -= i ? 1 : 0, i;
}
var Ul = Wl, Nl = Yt;
function Yl(a) {
  return Nl(this, a).get(a);
}
var Gl = Yl, Kl = Yt;
function Xl(a) {
  return Kl(this, a).has(a);
}
var Bl = Xl, Vl = Yt;
function ql(a, i) {
  var s = Vl(this, a), u = s.size;
  return s.set(a, i), this.size += s.size == u ? 0 : 1, this;
}
var Zl = ql, Jl = Rl, Ql = Ul, ec = Gl, tc = Bl, rc = Zl;
function tt(a) {
  var i = -1, s = a == null ? 0 : a.length;
  for (this.clear(); ++i < s; ) {
    var u = a[i];
    this.set(u[0], u[1]);
  }
}
tt.prototype.clear = Jl;
tt.prototype.delete = Ql;
tt.prototype.get = ec;
tt.prototype.has = tc;
tt.prototype.set = rc;
var Ii = tt, nc = Wt, ic = zr, oc = Ii, sc = 200;
function ac(a, i) {
  var s = this.__data__;
  if (s instanceof nc) {
    var u = s.__data__;
    if (!ic || u.length < sc - 1)
      return u.push([a, i]), this.size = ++s.size, this;
    s = this.__data__ = new oc(u);
  }
  return s.set(a, i), this.size = s.size, this;
}
var lc = ac, cc = Wt, uc = qs, pc = Js, hc = ea, dc = ra, fc = lc;
function rt(a) {
  var i = this.__data__ = new cc(a);
  this.size = i.size;
}
rt.prototype.clear = uc;
rt.prototype.delete = pc;
rt.prototype.get = hc;
rt.prototype.has = dc;
rt.prototype.set = fc;
var vc = rt, gc = "__lodash_hash_undefined__";
function mc(a) {
  return this.__data__.set(a, gc), this;
}
var bc = mc;
function yc(a) {
  return this.__data__.has(a);
}
var Tc = yc, wc = Ii, Sc = bc, xc = Tc;
function jt(a) {
  var i = -1, s = a == null ? 0 : a.length;
  for (this.__data__ = new wc(); ++i < s; )
    this.add(a[i]);
}
jt.prototype.add = jt.prototype.push = Sc;
jt.prototype.has = xc;
var Oc = jt;
function _c(a, i) {
  for (var s = -1, u = a == null ? 0 : a.length; ++s < u; )
    if (i(a[s], s, a))
      return !0;
  return !1;
}
var Mc = _c;
function Cc(a, i) {
  return a.has(i);
}
var Ec = Cc, Ic = Oc, Pc = Mc, Dc = Ec, $c = 1, kc = 2;
function zc(a, i, s, u, f, v) {
  var m = s & $c, y = a.length, x = i.length;
  if (y != x && !(m && x > y))
    return !1;
  var O = v.get(a), k = v.get(i);
  if (O && k)
    return O == i && k == a;
  var P = -1, T = !0, C = s & kc ? new Ic() : void 0;
  for (v.set(a, i), v.set(i, a); ++P < y; ) {
    var M = a[P], _ = i[P];
    if (u)
      var z = m ? u(_, M, P, i, a, v) : u(M, _, P, a, i, v);
    if (z !== void 0) {
      if (z)
        continue;
      T = !1;
      break;
    }
    if (C) {
      if (!Pc(i, function(X, Y) {
        if (!Dc(C, Y) && (M === X || f(M, X, s, u, v)))
          return C.push(Y);
      })) {
        T = !1;
        break;
      }
    } else if (!(M === _ || f(M, _, s, u, v))) {
      T = !1;
      break;
    }
  }
  return v.delete(a), v.delete(i), T;
}
var Pi = zc, Rc = $e, jc = Rc.Uint8Array, Ac = jc;
function Lc(a) {
  var i = -1, s = Array(a.size);
  return a.forEach(function(u, f) {
    s[++i] = [f, u];
  }), s;
}
var Hc = Lc;
function Fc(a) {
  var i = -1, s = Array(a.size);
  return a.forEach(function(u) {
    s[++i] = u;
  }), s;
}
var Wc = Fc, Yn = kr, Gn = Ac, Uc = xi, Nc = Pi, Yc = Hc, Gc = Wc, Kc = 1, Xc = 2, Bc = "[object Boolean]", Vc = "[object Date]", qc = "[object Error]", Zc = "[object Map]", Jc = "[object Number]", Qc = "[object RegExp]", eu = "[object Set]", tu = "[object String]", ru = "[object Symbol]", nu = "[object ArrayBuffer]", iu = "[object DataView]", Kn = Yn ? Yn.prototype : void 0, br = Kn ? Kn.valueOf : void 0;
function ou(a, i, s, u, f, v, m) {
  switch (s) {
    case iu:
      if (a.byteLength != i.byteLength || a.byteOffset != i.byteOffset)
        return !1;
      a = a.buffer, i = i.buffer;
    case nu:
      return !(a.byteLength != i.byteLength || !v(new Gn(a), new Gn(i)));
    case Bc:
    case Vc:
    case Jc:
      return Uc(+a, +i);
    case qc:
      return a.name == i.name && a.message == i.message;
    case Qc:
    case tu:
      return a == i + "";
    case Zc:
      var y = Yc;
    case eu:
      var x = u & Kc;
      if (y || (y = Gc), a.size != i.size && !x)
        return !1;
      var O = m.get(a);
      if (O)
        return O == i;
      u |= Xc, m.set(a, i);
      var k = Nc(y(a), y(i), u, f, v, m);
      return m.delete(a), k;
    case ru:
      if (br)
        return br.call(a) == br.call(i);
  }
  return !1;
}
var su = ou;
function au(a, i) {
  for (var s = -1, u = i.length, f = a.length; ++s < u; )
    a[f + s] = i[s];
  return a;
}
var lu = au, cu = Array.isArray, Rr = cu, uu = lu, pu = Rr;
function hu(a, i, s) {
  var u = i(a);
  return pu(a) ? u : uu(u, s(a));
}
var du = hu;
function fu(a, i) {
  for (var s = -1, u = a == null ? 0 : a.length, f = 0, v = []; ++s < u; ) {
    var m = a[s];
    i(m, s, a) && (v[f++] = m);
  }
  return v;
}
var vu = fu;
function gu() {
  return [];
}
var mu = gu, bu = vu, yu = mu, Tu = Object.prototype, wu = Tu.propertyIsEnumerable, Xn = Object.getOwnPropertySymbols, Su = Xn ? function(a) {
  return a == null ? [] : (a = Object(a), bu(Xn(a), function(i) {
    return wu.call(a, i);
  }));
} : yu, xu = Su;
function Ou(a, i) {
  for (var s = -1, u = Array(a); ++s < a; )
    u[s] = i(s);
  return u;
}
var _u = Ou;
function Mu(a) {
  return a != null && typeof a == "object";
}
var Gt = Mu, Cu = Ut, Eu = Gt, Iu = "[object Arguments]";
function Pu(a) {
  return Eu(a) && Cu(a) == Iu;
}
var Du = Pu, Bn = Du, $u = Gt, Di = Object.prototype, ku = Di.hasOwnProperty, zu = Di.propertyIsEnumerable, Ru = Bn(/* @__PURE__ */ function() {
  return arguments;
}()) ? Bn : function(a) {
  return $u(a) && ku.call(a, "callee") && !zu.call(a, "callee");
}, ju = Ru, At = { exports: {} };
function Au() {
  return !1;
}
var Lu = Au;
At.exports;
(function(a, i) {
  var s = $e, u = Lu, f = i && !i.nodeType && i, v = f && !0 && a && !a.nodeType && a, m = v && v.exports === f, y = m ? s.Buffer : void 0, x = y ? y.isBuffer : void 0, O = x || u;
  a.exports = O;
})(At, At.exports);
var $i = At.exports, Hu = 9007199254740991, Fu = /^(?:0|[1-9]\d*)$/;
function Wu(a, i) {
  var s = typeof a;
  return i = i ?? Hu, !!i && (s == "number" || s != "symbol" && Fu.test(a)) && a > -1 && a % 1 == 0 && a < i;
}
var Uu = Wu, Nu = 9007199254740991;
function Yu(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= Nu;
}
var ki = Yu, Gu = Ut, Ku = ki, Xu = Gt, Bu = "[object Arguments]", Vu = "[object Array]", qu = "[object Boolean]", Zu = "[object Date]", Ju = "[object Error]", Qu = "[object Function]", ep = "[object Map]", tp = "[object Number]", rp = "[object Object]", np = "[object RegExp]", ip = "[object Set]", op = "[object String]", sp = "[object WeakMap]", ap = "[object ArrayBuffer]", lp = "[object DataView]", cp = "[object Float32Array]", up = "[object Float64Array]", pp = "[object Int8Array]", hp = "[object Int16Array]", dp = "[object Int32Array]", fp = "[object Uint8Array]", vp = "[object Uint8ClampedArray]", gp = "[object Uint16Array]", mp = "[object Uint32Array]", oe = {};
oe[cp] = oe[up] = oe[pp] = oe[hp] = oe[dp] = oe[fp] = oe[vp] = oe[gp] = oe[mp] = !0;
oe[Bu] = oe[Vu] = oe[ap] = oe[qu] = oe[lp] = oe[Zu] = oe[Ju] = oe[Qu] = oe[ep] = oe[tp] = oe[rp] = oe[np] = oe[ip] = oe[op] = oe[sp] = !1;
function bp(a) {
  return Xu(a) && Ku(a.length) && !!oe[Gu(a)];
}
var yp = bp;
function Tp(a) {
  return function(i) {
    return a(i);
  };
}
var wp = Tp, Lt = { exports: {} };
Lt.exports;
(function(a, i) {
  var s = Oi, u = i && !i.nodeType && i, f = u && !0 && a && !a.nodeType && a, v = f && f.exports === u, m = v && s.process, y = function() {
    try {
      var x = f && f.require && f.require("util").types;
      return x || m && m.binding && m.binding("util");
    } catch {
    }
  }();
  a.exports = y;
})(Lt, Lt.exports);
var Sp = Lt.exports, xp = yp, Op = wp, Vn = Sp, qn = Vn && Vn.isTypedArray, _p = qn ? Op(qn) : xp, zi = _p, Mp = _u, Cp = ju, Ep = Rr, Ip = $i, Pp = Uu, Dp = zi, $p = Object.prototype, kp = $p.hasOwnProperty;
function zp(a, i) {
  var s = Ep(a), u = !s && Cp(a), f = !s && !u && Ip(a), v = !s && !u && !f && Dp(a), m = s || u || f || v, y = m ? Mp(a.length, String) : [], x = y.length;
  for (var O in a)
    (i || kp.call(a, O)) && !(m && // Safari 9 has enumerable `arguments.length` in strict mode.
    (O == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    f && (O == "offset" || O == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    v && (O == "buffer" || O == "byteLength" || O == "byteOffset") || // Skip index properties.
    Pp(O, x))) && y.push(O);
  return y;
}
var Rp = zp, jp = Object.prototype;
function Ap(a) {
  var i = a && a.constructor, s = typeof i == "function" && i.prototype || jp;
  return a === s;
}
var Lp = Ap;
function Hp(a, i) {
  return function(s) {
    return a(i(s));
  };
}
var Fp = Hp, Wp = Fp, Up = Wp(Object.keys, Object), Np = Up, Yp = Lp, Gp = Np, Kp = Object.prototype, Xp = Kp.hasOwnProperty;
function Bp(a) {
  if (!Yp(a))
    return Gp(a);
  var i = [];
  for (var s in Object(a))
    Xp.call(a, s) && s != "constructor" && i.push(s);
  return i;
}
var Vp = Bp, qp = Ci, Zp = ki;
function Jp(a) {
  return a != null && Zp(a.length) && !qp(a);
}
var Qp = Jp, eh = Rp, th = Vp, rh = Qp;
function nh(a) {
  return rh(a) ? eh(a) : th(a);
}
var ih = nh, oh = du, sh = xu, ah = ih;
function lh(a) {
  return oh(a, ah, sh);
}
var ch = lh, Zn = ch, uh = 1, ph = Object.prototype, hh = ph.hasOwnProperty;
function dh(a, i, s, u, f, v) {
  var m = s & uh, y = Zn(a), x = y.length, O = Zn(i), k = O.length;
  if (x != k && !m)
    return !1;
  for (var P = x; P--; ) {
    var T = y[P];
    if (!(m ? T in i : hh.call(i, T)))
      return !1;
  }
  var C = v.get(a), M = v.get(i);
  if (C && M)
    return C == i && M == a;
  var _ = !0;
  v.set(a, i), v.set(i, a);
  for (var z = m; ++P < x; ) {
    T = y[P];
    var X = a[T], Y = i[T];
    if (u)
      var ee = m ? u(Y, X, T, i, a, v) : u(X, Y, T, a, i, v);
    if (!(ee === void 0 ? X === Y || f(X, Y, s, u, v) : ee)) {
      _ = !1;
      break;
    }
    z || (z = T == "constructor");
  }
  if (_ && !z) {
    var te = a.constructor, ne = i.constructor;
    te != ne && "constructor" in a && "constructor" in i && !(typeof te == "function" && te instanceof te && typeof ne == "function" && ne instanceof ne) && (_ = !1);
  }
  return v.delete(a), v.delete(i), _;
}
var fh = dh, vh = Qe, gh = $e, mh = vh(gh, "DataView"), bh = mh, yh = Qe, Th = $e, wh = yh(Th, "Promise"), Sh = wh, xh = Qe, Oh = $e, _h = xh(Oh, "Set"), Mh = _h, Ch = Qe, Eh = $e, Ih = Ch(Eh, "WeakMap"), Ph = Ih, Tr = bh, wr = zr, Sr = Sh, xr = Mh, Or = Ph, Ri = Ut, nt = Ei, Jn = "[object Map]", Dh = "[object Object]", Qn = "[object Promise]", ei = "[object Set]", ti = "[object WeakMap]", ri = "[object DataView]", $h = nt(Tr), kh = nt(wr), zh = nt(Sr), Rh = nt(xr), jh = nt(Or), Ge = Ri;
(Tr && Ge(new Tr(new ArrayBuffer(1))) != ri || wr && Ge(new wr()) != Jn || Sr && Ge(Sr.resolve()) != Qn || xr && Ge(new xr()) != ei || Or && Ge(new Or()) != ti) && (Ge = function(a) {
  var i = Ri(a), s = i == Dh ? a.constructor : void 0, u = s ? nt(s) : "";
  if (u)
    switch (u) {
      case $h:
        return ri;
      case kh:
        return Jn;
      case zh:
        return Qn;
      case Rh:
        return ei;
      case jh:
        return ti;
    }
  return i;
});
var Ah = Ge, yr = vc, Lh = Pi, Hh = su, Fh = fh, ni = Ah, ii = Rr, oi = $i, Wh = zi, Uh = 1, si = "[object Arguments]", ai = "[object Array]", Dt = "[object Object]", Nh = Object.prototype, li = Nh.hasOwnProperty;
function Yh(a, i, s, u, f, v) {
  var m = ii(a), y = ii(i), x = m ? ai : ni(a), O = y ? ai : ni(i);
  x = x == si ? Dt : x, O = O == si ? Dt : O;
  var k = x == Dt, P = O == Dt, T = x == O;
  if (T && oi(a)) {
    if (!oi(i))
      return !1;
    m = !0, k = !1;
  }
  if (T && !k)
    return v || (v = new yr()), m || Wh(a) ? Lh(a, i, s, u, f, v) : Hh(a, i, x, s, u, f, v);
  if (!(s & Uh)) {
    var C = k && li.call(a, "__wrapped__"), M = P && li.call(i, "__wrapped__");
    if (C || M) {
      var _ = C ? a.value() : a, z = M ? i.value() : i;
      return v || (v = new yr()), f(_, z, s, u, v);
    }
  }
  return T ? (v || (v = new yr()), Fh(a, i, s, u, f, v)) : !1;
}
var Gh = Yh, Kh = Gh, ci = Gt;
function ji(a, i, s, u, f) {
  return a === i ? !0 : a == null || i == null || !ci(a) && !ci(i) ? a !== a && i !== i : Kh(a, i, s, u, ji, f);
}
var Xh = ji, Bh = Xh;
function Vh(a, i) {
  return Bh(a, i);
}
var qh = Vh;
const _r = /* @__PURE__ */ Ze(qh);
function J(a, i) {
  return typeof a.get == "function" ? a.get(i) : a[i];
}
function ui(a) {
  return typeof a.count == "function" ? a.count() : a.length;
}
function gt(a, i) {
  return ui(a) === ui(i) && a.every((s, u) => s === J(i, u.toString()));
}
function Zh(a, i) {
  const s = {};
  return a.forEach((u) => {
    s[u[i]] = u;
  }), s;
}
function $t() {
}
function Ke(...a) {
  return (i, ...s) => {
    i.preventDefault(), a.forEach((u) => u && u(i, ...s));
  };
}
function Jh({ item: a, itemContext: i, getItemProps: s, getResizeProps: u }) {
  const { left: f, right: v } = u();
  return Xe("div", { ...s(a.itemProps), children: [i.useResizeHandle ? H("div", { ...f }) : "", H("div", { className: "rct-item-content", style: { maxHeight: `${i.dimensions.height}` }, children: i.title }), i.useResizeHandle ? H("div", { ...v }) : ""] });
}
function Mr(a, i, s) {
  return (i - a) / s;
}
function Ht(a, i, s, u) {
  const f = s / (i - a);
  return (u - a) * f;
}
function jr(a, i, s, u) {
  return (i - a) / s * u + a;
}
function Ar(a, i, s, u, f) {
  let v = De(a).startOf(s);
  if (u[s] && u[s] > 1) {
    const m = v.get(s);
    v.set(s, m - m % u[s]);
  }
  for (; v.valueOf() < i; ) {
    const m = De(v).add(u[s] || 1, s);
    f(v, m), v = m;
  }
}
const Cr = 17;
function kt(a, i, s) {
  const u = {
    second: 1e3,
    minute: 60,
    hour: 60,
    day: 24,
    month: 30,
    year: 12
  };
  let f = "year", v = a;
  return Object.keys(u).some((m) => {
    const y = m;
    v = v / u[y];
    const x = v / s[y], O = s[y] && s[y] > 1 ? 3 * Cr : Cr, k = i / O;
    if (x < k)
      return f = m, !0;
  }), f;
}
const Er = {
  second: "minute",
  minute: "hour",
  hour: "day",
  day: "month",
  month: "year",
  year: "year"
};
function Lr(a) {
  if (!Er[a])
    throw new Error(`unit ${a} is not acceptable`);
  return Er[a];
}
function Ai({ itemTimeStart: a, itemTimeEnd: i, dragTime: s, isDragging: u, isResizing: f, resizingEdge: v, resizeTime: m }) {
  const y = i - a;
  return [
    u && s ? s : f && v === "left" && m ? m : a,
    u && s ? s + y : f && v === "right" && m ? m : i
  ];
}
function Li({ itemTimeStart: a, itemTimeEnd: i, canvasTimeStart: s, canvasTimeEnd: u, canvasWidth: f }) {
  const v = i - a, m = Math.max(a, s), y = Math.min(i, u), x = Ht(s, u, f, m), k = Ht(s, u, f, y) - x;
  return {
    left: x,
    width: Math.max(k, 3),
    collisionLeft: a,
    collisionWidth: v
  };
}
function Hr(a, i) {
  const { groupIdKey: s } = i, u = {};
  for (let f = 0; f < a.length; f++)
    u[J(a[f], s)] = {
      index: f,
      group: a[f]
    };
  return u;
}
function Hi(a, i) {
  var f, v;
  const s = {}, u = Object.keys(i);
  for (let m = 0; m < u.length; m++) {
    const y = i[u[m]];
    s[m] = {
      index: y.index,
      group: y.group,
      items: []
    };
  }
  for (let m = 0; m < a.length; m++)
    if (a[m].dimensions !== void 0 && ((f = a[m].dimensions) == null ? void 0 : f.order) !== void 0) {
      const y = s[((v = a[m].dimensions) == null ? void 0 : v.order.index) ?? 0];
      y && y.items.push(a[m]);
    }
  return s;
}
function Fr(a, i, s, u) {
  const { itemTimeStartKey: f, itemTimeEndKey: v } = u;
  return a.filter((m) => {
    const y = De(J(m, f)).valueOf() <= s, x = De(J(m, v)).valueOf() >= i;
    return y && x;
  });
}
const Qh = 1e-3;
function Fi(a, i, s = Qh) {
  return a.collisionLeft + s < i.collisionLeft + i.collisionWidth && a.collisionLeft + a.collisionWidth - s > i.collisionLeft && a.top - 0 + s < i.top + i.height && a.top + a.height + 0 - s > i.top;
}
function Wi(a, i, s, u, f, v) {
  let m = u;
  const y = (a - i.dimensions.height) / 2;
  if (i.dimensions.stack && i.dimensions.top === null) {
    i.dimensions.top = f + y, m = Math.max(m, a);
    do {
      var x = null;
      for (let O = v - 1, k = 0; O >= k; O--) {
        const P = s[O];
        if (P.dimensions.top !== null && P.dimensions.stack && Fi(i.dimensions, P.dimensions)) {
          x = P;
          break;
        }
      }
      x != null && (i.dimensions.top = x.dimensions.top + a, m = Math.max(m, i.dimensions.top + i.dimensions.height + y - f));
    } while (x);
  }
  return {
    groupHeight: m,
    verticalMargin: y,
    itemTop: i.dimensions.top
  };
}
function Ui(a, i, s, u) {
  var v, m;
  const f = (a - (((v = i.dimensions) == null ? void 0 : v.height) ?? 1)) / 2;
  return i.dimensions && i.dimensions.top === null && (i.dimensions.top = u + f, s = Math.max(s, a)), { groupHeight: s, verticalMargin: 0, itemTop: ((m = i.dimensions) == null ? void 0 : m.top) ?? 0 };
}
function pi(a = []) {
  return a.reduce((i, s) => i + s, 0);
}
function Ni(a, i, s, u) {
  const f = [], v = [], m = Hi(a, i);
  for (const y in m) {
    const x = m[y], { items: O, group: k } = x, P = pi(f), T = k.stackItems !== void 0 ? k.stackItems : u, { groupHeight: C } = Yi(O, T, s, P);
    v.push(P), k.height ? f.push(k.height) : f.push(Math.max(C, s));
  }
  return {
    height: pi(f),
    groupHeights: f,
    groupTops: v
  };
}
function Yi(a, i, s, u) {
  let f = 0, v = 0;
  for (let m = 0; m < a.length; m++) {
    const y = i ? Wi(s, a[m], a, f, u, m) : Ui(s, a[m], f, u);
    f = y.groupHeight, v = y.verticalMargin;
  }
  return { groupHeight: f, verticalMargin: v };
}
function qe(a, i, s, u, f, v, m, y, x, O, k, P, T, C, M) {
  const z = Fr(a, u, f, v).map((ue) => Ki({
    item: ue,
    keys: v,
    draggingItem: O,
    resizingItem: k,
    dragTime: P,
    resizingEdge: T,
    resizeTime: C,
    groups: i,
    newGroupOrder: M
  }));
  if (i.length === 0)
    return {
      dimensionItems: [],
      height: 0,
      groupHeights: [],
      groupTops: []
    };
  const X = Hr(i, v), Y = z.map((ue) => Gi({
    item: ue,
    keys: v,
    canvasTimeStart: u,
    canvasTimeEnd: f,
    canvasWidth: s,
    groupOrders: X,
    lineHeight: m,
    itemHeightRatio: y
  })).filter((ue) => !!ue), { height: ee, groupHeights: te, groupTops: ne } = Ni(Y, X, m, x);
  return { dimensionItems: Y, height: ee, groupHeights: te, groupTops: ne };
}
function He(a, i) {
  return a * i;
}
function Gi({ item: a, keys: i, canvasTimeStart: s, canvasTimeEnd: u, canvasWidth: f, groupOrders: v, lineHeight: m, itemHeightRatio: y }) {
  const x = J(a, i.itemIdKey), O = Li({
    itemTimeStart: J(a, i.itemTimeStartKey),
    itemTimeEnd: J(a, i.itemTimeEndKey),
    canvasTimeStart: s,
    canvasTimeEnd: u,
    canvasWidth: f
  });
  if (O)
    return O.top = null, O.order = v[J(a, i.itemGroupKey)], O.stack = !a.isOverlay, O.height = m * y, {
      id: x,
      dimensions: O
    };
}
function Ki({ item: a, keys: i, draggingItem: s, resizingItem: u, dragTime: f, resizingEdge: v, resizeTime: m, groups: y, newGroupOrder: x }) {
  if (!u && !s)
    return a;
  const O = J(a, i.itemIdKey), k = O === s, P = O === u, [T, C] = Ai({
    itemTimeStart: J(a, i.itemTimeStartKey),
    itemTimeEnd: J(a, i.itemTimeEndKey),
    isDragging: k,
    isResizing: P,
    dragTime: f,
    resizingEdge: v,
    resizeTime: m
  });
  return {
    ...a,
    [i.itemTimeStartKey]: T,
    [i.itemTimeEndKey]: C,
    [i.itemGroupKey]: k ? J(y[x], i.groupIdKey) : J(a, i.itemGroupKey)
  };
}
function Wr(a, i, s) {
  const u = i - a, f = a - u * (s - 1) / 2, v = f + u * s;
  return [f, v];
}
function Ir(a, i, s, u, f, v, m) {
  const y = v.buffer, x = m.canvasTimeStart, O = m.canvasTimeEnd, k = m.visibleTimeEnd - m.visibleTimeStart, P = i - a, T = {
    ...m,
    visibleTimeStart: a,
    visibleTimeEnd: i
  };
  if (!(P === k && a >= x + k * 0.5 && a <= O - k * 1.5 && i >= x + k * 1.5 && i <= O - k * 0.5) || s) {
    const [M, _] = Wr(a, i, y);
    T.canvasTimeStart = M, T.canvasTimeEnd = _;
    const z = {
      ...m,
      ...T
    }, X = He(z.width, v.buffer);
    Object.assign(T, qe(u, f, X, z.canvasTimeStart, z.canvasTimeEnd, v.keys, v.lineHeight, v.itemHeightRatio, v.stackItems, z.draggingItem, z.resizingItem, z.dragTime, z.resizingEdge, z.resizeTime, z.newGroupOrder));
  }
  return T;
}
const bf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NEXT_UNITS: Er,
  calculateDimensions: Li,
  calculateInteractionNewTimes: Ai,
  calculateScrollCanvas: Ir,
  calculateTimeForXPosition: jr,
  calculateXPositionForTime: Ht,
  collision: Fi,
  coordinateToTimeRatio: Mr,
  getCanvasBoundariesFromVisibleTime: Wr,
  getCanvasWidth: He,
  getGroupOrders: Hr,
  getGroupedItems: Hi,
  getItemDimensions: Gi,
  getItemWithInteractions: Ki,
  getMinUnit: kt,
  getNextUnit: Lr,
  getVisibleItems: Fr,
  groupNoStack: Ui,
  groupStack: Wi,
  iterateTimes: Ar,
  minCellWidth: Cr,
  stackAll: Ni,
  stackGroup: Yi,
  stackTimelineItems: qe
}, Symbol.toStringTag, { value: "Module" }));
function hi(a) {
  let i = 0, s = 0, u = !0;
  for (; a; )
    !a.offsetParent && a.tagName === "BODY" && a.scrollLeft === 0 && a.scrollTop === 0 && (a = document.scrollingElement || a), i += a.offsetLeft - (u ? 0 : a.scrollLeft) + a.clientLeft, s += a.offsetTop - (u ? 0 : a.scrollTop) + a.clientTop, a = a.offsetParent, u = !1;
  return { x: i, y: s };
}
function Pr(a) {
  if (a === document.body)
    return { scrollLeft: 0, scrollTop: 0 };
  {
    const i = Pr(a.parentNode);
    return {
      scrollLeft: a.scrollLeft + i.scrollLeft,
      scrollTop: a.scrollTop + i.scrollTop
    };
  }
}
function Dr(a) {
  if (a === document.body || !a.offsetParent)
    return { offsetLeft: 0, offsetTop: 0 };
  {
    const i = Dr(a.offsetParent);
    return {
      offsetLeft: a.offsetLeft + i.offsetLeft,
      offsetTop: a.offsetTop + i.offsetTop
    };
  }
}
const ed = {
  fontSize: 12,
  color: "white",
  cursor: "pointer",
  background: "#2196f3",
  border: "1px solid #1a6fb3",
  zIndex: 80
}, td = {
  background: "#ffc107",
  border: "1px solid #ff9800",
  zIndex: 82
}, rd = {
  willChange: "left, top, width",
  cursor: "move"
}, nd = {
  borderLeftWidth: 3
}, id = {
  cursor: "w-resize"
}, od = {
  borderRightWidth: 3
}, sd = {
  cursor: "e-resize"
}, ad = {
  position: "absolute",
  width: 24,
  maxWidth: "20%",
  minWidth: 2,
  height: "100%",
  top: 0,
  left: 0,
  cursor: "pointer",
  zIndex: 88
}, ld = {
  position: "absolute",
  width: 24,
  maxWidth: "20%",
  minWidth: 2,
  height: "100%",
  top: 0,
  right: 0,
  cursor: "pointer",
  zIndex: 88
}, cd = {
  getTimelineState: () => (console.warn('"getTimelineState" default func is being used'), {}),
  getLeftOffsetFromDate: () => (console.warn('"getLeftOffsetFromDate" default func is being used'), 0),
  getDateFromLeftOffsetPosition: () => (console.warn('"getDateFromLeftOffsetPosition" default func is being used'), 0),
  showPeriod: () => {
    console.warn('"showPeriod" default func is being used');
  }
}, Ur = se.createContext(cd), { Consumer: ud, Provider: pd } = Ur;
class hd extends se.Component {
  constructor(i) {
    super(i), Object.defineProperty(this, "getTimelineState", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { visibleTimeStart: s, visibleTimeEnd: u, canvasTimeStart: f, canvasTimeEnd: v, canvasWidth: m, timelineUnit: y, timelineWidth: x } = this.props;
        return {
          visibleTimeStart: s,
          visibleTimeEnd: u,
          canvasTimeStart: f,
          canvasTimeEnd: v,
          canvasWidth: m,
          timelineUnit: y,
          timelineWidth: x
        };
      }
    }), Object.defineProperty(this, "getLeftOffsetFromDate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        const { canvasTimeStart: u, canvasTimeEnd: f, canvasWidth: v } = this.props;
        return Ht(u, f, v, s);
      }
    }), Object.defineProperty(this, "getDateFromLeftOffsetPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        const { canvasTimeStart: u, canvasTimeEnd: f, canvasWidth: v } = this.props;
        return jr(u, f, v, s);
      }
    }), this.state = {
      timelineContext: {
        getTimelineState: this.getTimelineState,
        getLeftOffsetFromDate: this.getLeftOffsetFromDate,
        getDateFromLeftOffsetPosition: this.getDateFromLeftOffsetPosition,
        showPeriod: this.props.showPeriod
      }
    };
  }
  render() {
    return H(pd, { value: this.state.timelineContext, children: this.props.children });
  }
}
const Kt = ud, dd = () => Ti(Ur);
De.extend(xs);
class Nr extends xe {
  constructor(i) {
    super(i), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        interactMounted: !1,
        dragging: !1,
        dragStart: null,
        preDragPosition: null,
        dragTime: null,
        dragGroupDelta: null,
        resizing: !1,
        resizeEdge: null,
        resizeStart: null,
        resizeTime: null
      }
    }), Object.defineProperty(this, "itemId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "itemTitle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "itemDivTitle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "itemTimeStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "itemTimeEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "item", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dragLeft", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dragRight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "startedClicking", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "startedTouching", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "dragInProgress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "fireInteractEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        if (this.item) {
          const u = new CustomEvent("itemInteraction", {
            bubbles: !0,
            detail: {
              itemInteraction: s
            }
          });
          this.item.dispatchEvent(u);
        }
      }
    }), Object.defineProperty(this, "onMouseDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.state.interactMounted || (s.preventDefault(), this.startedClicking = !0);
      }
    }), Object.defineProperty(this, "onMouseUp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        !this.state.interactMounted && this.startedClicking && (this.startedClicking = !1, this.actualClick(s, "click"));
      }
    }), Object.defineProperty(this, "onTouchStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.state.interactMounted || (s.preventDefault(), this.startedTouching = !0);
      }
    }), Object.defineProperty(this, "onTouchEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        !this.state.interactMounted && this.startedTouching && (this.startedTouching = !1, this.actualClick(s, "touch"));
      }
    }), Object.defineProperty(this, "handleDoubleClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        s.stopPropagation(), this.props.onItemDoubleClick && this.props.onItemDoubleClick(this.itemId, s);
      }
    }), Object.defineProperty(this, "handleContextMenu", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.props.onContextMenu && (s.preventDefault(), s.stopPropagation(), this.props.onContextMenu(this.itemId, s));
      }
    }), Object.defineProperty(this, "getItemRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => this.item = s
    }), Object.defineProperty(this, "getDragLeftRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => this.dragLeft = s
    }), Object.defineProperty(this, "getDragRightRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => this.dragRight = s
    }), Object.defineProperty(this, "getItemProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s = {}) => {
        const u = "rct-item" + (this.props.item.className ? ` ${this.props.item.className}` : "");
        return {
          key: this.itemId,
          ref: this.getItemRef,
          title: this.itemDivTitle,
          className: u + ` ${s.className ? s.className : ""}`,
          onMouseDown: Ke(this.onMouseDown, s.onMouseDown),
          onMouseUp: Ke(this.onMouseUp, s.onMouseUp),
          onTouchStart: Ke(this.onTouchStart, s.onTouchStart),
          onTouchEnd: Ke(this.onTouchEnd, s.onTouchEnd),
          onDoubleClick: Ke(this.handleDoubleClick, s.onDoubleClick),
          onContextMenu: Ke(this.handleContextMenu, s.onContextMenu),
          style: Object.assign({}, this.getItemStyle(s))
        };
      }
    }), Object.defineProperty(this, "getResizeProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s = {}) => {
        let u = "rct-item-handler rct-item-handler-left rct-item-handler-resize-left";
        s.leftClassName && (u += ` ${s.leftClassName}`);
        let f = "rct-item-handler rct-item-handler-right rct-item-handler-resize-right";
        return s.rightClassName && (f += ` ${s.rightClassName}`), {
          left: {
            ref: this.getDragLeftRef,
            className: u,
            style: Object.assign({}, ad, s.leftStyle)
          },
          right: {
            ref: this.getDragRightRef,
            className: f,
            style: Object.assign({}, ld, s.rightStyle)
          }
        };
      }
    }), this.cacheDataFromProps(i);
  }
  shouldComponentUpdate(i, s) {
    return !_r(this.props, i) || !_r(this.state, s);
  }
  cacheDataFromProps(i) {
    this.itemId = J(i.item, i.keys.itemIdKey), this.itemTitle = J(i.item, i.keys.itemTitleKey), this.itemDivTitle = i.keys.itemDivTitleKey ? J(i.item, i.keys.itemDivTitleKey) : this.itemTitle, this.itemTimeStart = J(i.item, i.keys.itemTimeStartKey), this.itemTimeEnd = J(i.item, i.keys.itemTimeEndKey);
  }
  getTimeRatio() {
    const { canvasTimeStart: i, canvasTimeEnd: s, canvasWidth: u } = this.props;
    return Mr(i, s, u);
  }
  dragTimeSnap(i, s) {
    const { dragSnap: u } = this.props;
    if (u) {
      const f = s ? De().utcOffset() * 60 * 1e3 : 0;
      return Math.round(i / u) * u - f % u;
    } else
      return i;
  }
  resizeTimeSnap(i) {
    const { dragSnap: s } = this.props;
    if (s) {
      const u = this.itemTimeEnd % s;
      return Math.round((i - u) / s) * s + u;
    } else
      return i;
  }
  dragTime(i) {
    const s = De(this.itemTimeStart);
    return this.state.dragging ? this.dragTimeSnap(this.timeFor(i) + this.state.dragStart.offset, !0) : s.valueOf();
  }
  timeFor(i) {
    const s = Mr(this.props.canvasTimeStart, this.props.canvasTimeEnd, this.props.canvasWidth), u = Dr(this.props.scrollRef).offsetLeft, f = Pr(this.props.scrollRef);
    return (i.pageX - u + f.scrollLeft) * s + this.props.canvasTimeStart;
  }
  dragGroupDelta(i) {
    const { groupTops: s, order: u } = this.props;
    if (this.state.dragging) {
      if (!this.props.canChangeGroup)
        return 0;
      let f = 0;
      const v = Dr(this.props.scrollRef).offsetTop, m = Pr(this.props.scrollRef);
      for (const y of Object.keys(s)) {
        const x = s[y];
        if (i.pageY - v + m.scrollTop > x)
          f = parseInt(y, 10) - u.index;
        else
          break;
      }
      return this.props.order.index + f < 0 ? 0 - this.props.order.index : f;
    } else
      return 0;
  }
  resizeTimeDelta(i, s) {
    const u = this.itemTimeEnd - this.itemTimeStart, f = this.dragTimeSnap((i.pageX - this.state.resizeStart) * this.getTimeRatio());
    return u + (s === "left" ? -f : f) < (this.props.dragSnap || 1e3) ? s === "left" ? u - (this.props.dragSnap || 1e3) : (this.props.dragSnap || 1e3) - u : f;
  }
  mountInteract() {
    const i = this.props.useResizeHandle ? ".rct-item-handler-resize-left" : !0, s = this.props.useResizeHandle ? ".rct-item-handler-resize-right" : !0;
    gr(this.item).resizable({
      edges: {
        left: this.canResizeLeft() && i,
        right: this.canResizeRight() && s,
        top: !1,
        bottom: !1
      },
      enabled: this.props.selected && (this.canResizeLeft() || this.canResizeRight())
    }).draggable({
      enabled: this.props.selected && this.canMove()
    }).styleCursor(!1).on("dragstart", (u) => {
      if (this.props.selected) {
        this.dragInProgress = !0, this.fireInteractEvent(!0);
        const f = this.timeFor(u);
        this.setState({
          dragging: !0,
          dragStart: {
            x: u.pageX,
            y: u.pageY,
            offset: this.itemTimeStart - f
          },
          preDragPosition: { x: u.target.offsetLeft, y: u.target.offsetTop },
          dragTime: this.itemTimeStart,
          dragGroupDelta: 0
        });
      } else
        return !1;
    }).on("dragmove", (u) => {
      this.state.dragging && this.setState((f) => {
        if (!this.dragInProgress)
          return { ...f };
        let v = this.dragTime(u);
        const m = this.dragGroupDelta(u);
        return this.props.moveResizeValidator && (v = this.props.moveResizeValidator("move", this.props.item, v)), this.props.onDrag && this.props.onDrag(this.itemId, v, this.props.order.index + m), {
          dragTime: v,
          dragGroupDelta: m
        };
      });
    }).on("dragend", (u) => {
      if (this.state.dragging) {
        if (this.props.onDrop) {
          this.dragInProgress = !1, this.fireInteractEvent(!1);
          let f = this.dragTime(u);
          this.props.moveResizeValidator && (f = this.props.moveResizeValidator("move", this.props.item, f)), this.props.onDrop(this.itemId, f, this.props.order.index + this.dragGroupDelta(u));
        }
        this.setState({
          dragging: !1,
          dragStart: null,
          preDragPosition: null,
          dragTime: null,
          dragGroupDelta: null
        });
      }
    }).on("resizestart", (u) => {
      if (this.props.selected)
        this.fireInteractEvent(!0), this.setState({
          resizing: !0,
          resizeEdge: null,
          // we don't know yet
          resizeStart: u.pageX,
          resizeTime: 0
        });
      else
        return !1;
    }).on("resizemove", (u) => {
      if (this.state.resizing) {
        let f = this.state.resizeEdge;
        f || (f = u.deltaRect.left !== 0 ? "left" : "right", this.setState({ resizeEdge: f }));
        let v = this.resizeTimeSnap(this.timeFor(u));
        this.props.moveResizeValidator && (v = this.props.moveResizeValidator("resize", this.props.item, v, f)), this.props.onResizing && this.props.onResizing(this.itemId, v, f), this.setState({
          resizeTime: v
        });
      }
    }).on("resizeend", (u) => {
      if (this.state.resizing) {
        this.fireInteractEvent(!1);
        const { resizeEdge: f } = this.state;
        let v = this.resizeTimeSnap(this.timeFor(u));
        this.props.moveResizeValidator && (v = this.props.moveResizeValidator("resize", this.props.item, v, f)), this.props.onResized && this.props.onResized(this.itemId, v, f, this.resizeTimeDelta(u, f)), this.setState({
          resizing: !1,
          resizeStart: null,
          resizeEdge: null,
          resizeTime: null
        });
      }
    }).on("tap", (u) => {
      this.actualClick(u, u.pointerType === "mouse" ? "click" : "touch");
    }), this.setState({
      interactMounted: !0
    });
  }
  canResizeLeft(i = this.props) {
    var u;
    return !i.canResizeLeft || i.minResizeWidth === void 0 ? !1 : parseInt((u = i.dimensions.width) == null ? void 0 : u.toString(), 10) >= i.minResizeWidth;
  }
  canResizeRight(i = this.props) {
    var u;
    return !i.canResizeRight || i.minResizeWidth === void 0 ? !1 : parseInt((u = i.dimensions.width) == null ? void 0 : u.toString(), 10) >= i.minResizeWidth;
  }
  canMove(i = this.props) {
    return !!i.canMove;
  }
  componentDidUpdate(i) {
    this.cacheDataFromProps(this.props);
    let { interactMounted: s } = this.state;
    const u = i.selected && this.canMove(i), f = i.selected && this.canResizeLeft(i), v = i.selected && this.canResizeRight(i), m = this.props.selected && this.canMove(this.props), y = this.props.selected && this.canResizeLeft(this.props), x = this.props.selected && this.canResizeRight(this.props);
    if (this.item) {
      if (this.props.selected && !s && (this.mountInteract(), s = !0), s && (f !== y || v !== x)) {
        const O = this.props.useResizeHandle ? this.dragLeft : !0, k = this.props.useResizeHandle ? this.dragRight : !0;
        gr(this.item).resizable({
          enabled: y || x,
          edges: {
            top: !1,
            bottom: !1,
            left: y && O,
            right: x && k
          }
        });
      }
      s && u !== m && gr(this.item).draggable({ enabled: m });
    } else
      s = !1;
    s !== this.state.interactMounted && this.setState({
      interactMounted: s
    });
  }
  actualClick(i, s) {
    this.props.canSelect && this.props.onSelect && this.props.onSelect(this.itemId, s, i);
  }
  getItemStyle(i) {
    const s = this.props.dimensions, u = {
      position: "absolute",
      boxSizing: "border-box",
      left: `${s.left}px`,
      top: `${s.top}px`,
      width: `${s.width}px`,
      height: `${s.height}px`,
      lineHeight: `${s.height}px`
    };
    return Object.assign({}, ed, this.props.selected ? td : {}, this.props.selected && this.canMove(this.props) ? rd : {}, this.props.selected && this.canResizeLeft(this.props) ? nd : {}, this.props.selected && this.canResizeLeft(this.props) && this.state.dragging ? id : {}, this.props.selected && this.canResizeRight(this.props) ? od : {}, this.props.selected && this.canResizeRight(this.props) && this.state.dragging ? sd : {}, i.style, u);
  }
  render() {
    var u, f;
    if (typeof this.props.order > "u" || this.props.order === null)
      return null;
    const i = this.context, s = {
      dimensions: this.props.dimensions,
      useResizeHandle: !!this.props.useResizeHandle,
      title: this.itemTitle,
      canMove: this.canMove(this.props),
      canResizeLeft: this.canResizeLeft(this.props),
      canResizeRight: this.canResizeRight(this.props),
      selected: this.props.selected,
      dragging: this.state.dragging,
      dragStart: this.state.dragStart,
      dragTime: this.state.dragTime,
      dragGroupDelta: this.state.dragGroupDelta,
      resizing: this.state.resizing,
      resizeEdge: this.state.resizeEdge,
      resizeStart: this.state.resizeStart,
      resizeTime: this.state.resizeTime
    };
    return (f = (u = this.props) == null ? void 0 : u.itemRenderer) == null ? void 0 : f.call(u, {
      item: this.props.item,
      timelineContext: i,
      itemContext: s,
      getItemProps: this.getItemProps,
      getResizeProps: this.getResizeProps
    });
  }
}
Object.defineProperty(Nr, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    selected: !1,
    itemRenderer: Jh
  }
});
Object.defineProperty(Nr, "contextType", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Ur
});
function fd(a, i) {
  const s = J(a, "canResize") !== void 0 ? J(a, "canResize") : i;
  return s === "left" || s === "both";
}
function vd(a, i) {
  const s = J(a, "canResize") !== void 0 ? J(a, "canResize") : i;
  return s === "right" || s === "both" || s === !0;
}
class gd extends xe {
  shouldComponentUpdate(i) {
    return !(gt(i.groups, this.props.groups) && gt(i.items, this.props.items) && gt(i.dimensionItems, this.props.dimensionItems) && i.keys === this.props.keys && i.canvasTimeStart === this.props.canvasTimeStart && i.canvasTimeEnd === this.props.canvasTimeEnd && i.canvasWidth === this.props.canvasWidth && i.selectedItem === this.props.selectedItem && i.selected === this.props.selected && i.dragSnap === this.props.dragSnap && i.minResizeWidth === this.props.minResizeWidth && i.canChangeGroup === this.props.canChangeGroup && i.canMove === this.props.canMove && i.canResize === this.props.canResize && i.canSelect === this.props.canSelect);
  }
  isSelected(i, s) {
    if (this.props.selected) {
      const u = J(i, s);
      return this.props.selected.includes(u);
    } else
      return this.props.selectedItem === J(i, s);
  }
  getVisibleItems(i, s) {
    const { keys: u, items: f } = this.props;
    return Fr(f, i, s, u);
  }
  render() {
    const { canvasTimeStart: i, canvasTimeEnd: s, dimensionItems: u, keys: f, groups: v } = this.props, { itemIdKey: m, itemGroupKey: y } = f, x = Hr(v, f), O = this.getVisibleItems(i, s), k = Zh(u, "id");
    return H("div", { className: "rct-items", children: O.filter((P) => k[J(P, m)]).map((P) => H(Nr, { itemProps: P.itemProps, item: P, keys: this.props.keys, order: x[J(P, y)], dimensions: k[J(P, m)].dimensions, selected: this.isSelected(P, m), canChangeGroup: J(P, "canChangeGroup") !== void 0 ? J(P, "canChangeGroup") : this.props.canChangeGroup, canMove: J(P, "canMove") !== void 0 ? J(P, "canMove") : this.props.canMove, canResizeLeft: fd(P, this.props.canResize), canResizeRight: vd(P, this.props.canResize), canSelect: J(P, "canSelect") !== void 0 ? J(P, "canSelect") : this.props.canSelect, useResizeHandle: this.props.useResizeHandle, groupTops: this.props.groupTops, canvasTimeStart: this.props.canvasTimeStart, canvasTimeEnd: this.props.canvasTimeEnd, canvasWidth: this.props.canvasWidth, dragSnap: this.props.dragSnap, minResizeWidth: this.props.minResizeWidth, onResizing: this.props.itemResizing, onResized: this.props.itemResized, moveResizeValidator: this.props.moveResizeValidator, onDrag: this.props.itemDrag, onDrop: this.props.itemDrop, onItemDoubleClick: this.props.onItemDoubleClick, onContextMenu: this.props.onItemContextMenu, onSelect: this.props.itemSelect, itemRenderer: this.props.itemRenderer, scrollRef: this.props.scrollRef }, J(P, m))) });
  }
}
class di extends xe {
  shouldComponentUpdate(i) {
    return !(i.keys === this.props.keys && i.width === this.props.width && i.height === this.props.height && gt(i.groups, this.props.groups) && gt(i.groupHeights, this.props.groupHeights));
  }
  renderGroupContent(i, s = !1, u, f) {
    return this.props.groupRenderer ? se.createElement(this.props.groupRenderer, {
      group: i,
      isRightSidebar: s
    }) : J(i, s ? f : u);
  }
  render() {
    const { width: i, groupHeights: s, height: u, isRightSidebar: f } = this.props, { groupIdKey: v, groupTitleKey: m, groupRightTitleKey: y } = this.props.keys, x = {
      width: `${i}px`,
      height: `${u}px`
    }, O = {
      width: `${i}px`
    }, k = this.props.groups.map((P, T) => {
      const C = {
        height: `${s[T]}px`,
        lineHeight: `${s[T]}px`
      };
      return H("div", { className: "rct-sidebar-row rct-sidebar-row-" + (T % 2 === 0 ? "even" : "odd"), style: C, children: this.renderGroupContent(P, f, m, y) }, J(P, v));
    });
    return H("div", { className: "rct-sidebar" + (f ? " rct-sidebar-right" : ""), style: x, children: H("div", { style: O, children: k }) });
  }
}
class md extends xe {
  shouldComponentUpdate(i) {
    return !(i.canvasTimeStart === this.props.canvasTimeStart && i.canvasTimeEnd === this.props.canvasTimeEnd && i.canvasWidth === this.props.canvasWidth && i.lineCount === this.props.lineCount && i.minUnit === this.props.minUnit && i.timeSteps === this.props.timeSteps && i.height === this.props.height && i.verticalLineClassNamesForTime === this.props.verticalLineClassNamesForTime);
  }
  render() {
    const {
      canvasTimeStart: i,
      canvasTimeEnd: s,
      // canvasWidth,
      minUnit: u,
      timeSteps: f,
      height: v,
      verticalLineClassNamesForTime: m,
      getLeftOffsetFromDate: y
    } = this.props, x = [];
    return Ar(i, s, u, f, (O, k) => {
      const T = O.get(u === "day" ? "date" : u) === (u === "day" ? 1 : 0);
      let C = [];
      m && (C = m(
        O.unix() * 1e3,
        // turn into ms, which is what verticalLineClassNamesForTime expects
        k.unix() * 1e3 - 1
      ));
      const M = "rct-vl" + (T ? " rct-vl-first" : "") + (u === "day" || u === "hour" || u === "minute" ? ` rct-day-${O.day()} ` : " ") + C.join(" "), _ = y(O.valueOf()), z = y(k.valueOf());
      x.push(H("div", { className: M, style: {
        pointerEvents: "none",
        top: "0px",
        left: `${_}px`,
        width: `${z - _}px`,
        height: `${v}px`
      } }, `line-${O.valueOf()}`));
    }), H("div", { className: "rct-vertical-lines", children: x });
  }
}
const bd = ({ ...a }) => H(Kt, { children: ({ getLeftOffsetFromDate: i }) => H(md, { getLeftOffsetFromDate: i, ...a }) });
class yd extends xe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "handleMouseDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.originClickX = i.clientX;
      }
    }), Object.defineProperty(this, "handleMouseUp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.props.clickTolerance !== void 0 && Math.abs(this.originClickX - i.clientX) > this.props.clickTolerance && (this.cancelClick = !0);
      }
    }), Object.defineProperty(this, "handleClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.cancelClick || this.props.onClick(i), this.cancelClick = !1, this.originClickX = null;
      }
    }), Object.defineProperty(this, "originClickX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cancelClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  render() {
    const i = se.Children.only(this.props.children);
    return se.cloneElement(i, {
      onMouseDown: this.handleMouseDown,
      onMouseUp: this.handleMouseUp,
      onClick: this.handleClick
    });
  }
}
class Td extends xe {
  render() {
    const { onContextMenu: i, onDoubleClick: s, isEvenRow: u, style: f, onClick: v, clickTolerance: m, horizontalLineClassNamesForGroup: y, group: x } = this.props;
    let O = [];
    return y && (O = y(x)), H(yd, { clickTolerance: m, onClick: v, children: H("div", { onContextMenu: i, onDoubleClick: s, className: (u ? "rct-hl-even " : "rct-hl-odd ") + (O ? O.join(" ") : ""), style: f }) });
  }
}
class wd extends xe {
  shouldComponentUpdate(i) {
    return !(i.canvasWidth === this.props.canvasWidth && i.lineCount === this.props.lineCount && i.groupHeights === this.props.groupHeights && i.groups === this.props.groups);
  }
  render() {
    const { canvasWidth: i, lineCount: s, groupHeights: u, onRowClick: f, onRowDoubleClick: v, clickTolerance: m, groups: y, horizontalLineClassNamesForGroup: x, onRowContextClick: O } = this.props, k = [];
    for (let P = 0; P < s; P++)
      k.push(H(Td, { clickTolerance: m, onContextMenu: (T) => O(T, P), onClick: (T) => f(T, P), onDoubleClick: (T) => v(T, P), isEvenRow: P % 2 === 0, group: y[P], horizontalLineClassNamesForGroup: x, style: {
        width: `${i}px`,
        height: `${u[P]}px`
      } }, `horizontal-line-${P}`));
    return H("div", { className: "rct-horizontal-lines", children: k });
  }
}
class Sd extends xe {
  constructor(i) {
    super(i), Object.defineProperty(this, "scrollComponent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "dragLastPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "lastTouchDistance", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "singleTouchStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "lastSingleTouch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "isItemInteraction", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "handleScroll", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const s = this.scrollComponent.scrollLeft;
        this.props.onScroll(s);
      }
    }), Object.defineProperty(this, "refHandler", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.scrollComponent = s, this.props.scrollRef(s), s && (s.addEventListener("wheel", this.handleWheel, { passive: !1 }), s.addEventListener("itemInteraction", this.handleItemInteract));
      }
    }), Object.defineProperty(this, "handleWheel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        if (s.ctrlKey || s.metaKey || s.altKey) {
          s.preventDefault();
          const u = hi(s.currentTarget), f = s.clientX - u.x, v = s.ctrlKey ? 10 : s.metaKey ? 3 : 1;
          this.props.onWheelZoom(v, f, s.deltaY);
        } else s.shiftKey && (s.preventDefault(), this.props.onScroll(this.scrollComponent.scrollLeft + (s.deltaY || s.deltaX)));
      }
    }), Object.defineProperty(this, "handleMouseDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        s.button === 0 && (this.dragLastPosition = s.pageX, this.setState({
          isDragging: !0
        }));
      }
    }), Object.defineProperty(this, "handleMouseMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.state.isDragging && !this.isItemInteraction && (this.props.onScroll(this.scrollComponent.scrollLeft + this.dragLastPosition - s.pageX), this.dragLastPosition = s.pageX);
      }
    }), Object.defineProperty(this, "handleMouseUp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.dragLastPosition = null, this.setState({
          isDragging: !1
        });
      }
    }), Object.defineProperty(this, "handleMouseLeave", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.dragLastPosition = null, this.setState({
          isDragging: !1
        });
      }
    }), Object.defineProperty(this, "handleTouchStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        if (s.touches.length === 2)
          s.preventDefault(), this.lastTouchDistance = Math.abs(s.touches[0].screenX - s.touches[1].screenX), this.singleTouchStart = null, this.lastSingleTouch = null;
        else if (s.touches.length === 1) {
          s.preventDefault();
          const u = s.touches[0].clientX, f = s.touches[0].clientY;
          this.lastTouchDistance = null, this.singleTouchStart = { x: u, y: f, screenY: window.pageYOffset }, this.lastSingleTouch = { x: u, y: f, screenY: window.pageYOffset };
        }
      }
    }), Object.defineProperty(this, "handleTouchMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        const { width: u, onZoom: f } = this.props;
        if (this.isItemInteraction) {
          s.preventDefault();
          return;
        }
        if (this.lastTouchDistance && s.touches.length === 2) {
          s.preventDefault();
          const v = Math.abs(s.touches[0].screenX - s.touches[1].screenX), m = hi(s.currentTarget), y = (s.touches[0].screenX + s.touches[1].screenX) / 2 - m.x;
          v !== 0 && this.lastTouchDistance !== 0 && (f(this.lastTouchDistance / v, y / u), this.lastTouchDistance = v);
        } else if (this.lastSingleTouch && s.touches.length === 1) {
          s.preventDefault();
          const v = s.touches[0].clientX, m = s.touches[0].clientY, y = v - this.lastSingleTouch.x, x = v - this.singleTouchStart.x, O = m - this.singleTouchStart.y;
          this.lastSingleTouch = { x: v, y: m, screenY: window.pageYOffset };
          const k = Math.abs(x) * 3 > Math.abs(O), P = Math.abs(O) * 3 > Math.abs(x);
          y !== 0 && k && this.props.onScroll(this.scrollComponent.scrollLeft - y), P && window.scrollTo(window.pageXOffset, this.singleTouchStart.screenY - O);
        }
      }
    }), Object.defineProperty(this, "handleTouchEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.lastTouchDistance && (this.lastTouchDistance = null), this.lastSingleTouch && (this.lastSingleTouch = null, this.singleTouchStart = null);
      }
    }), Object.defineProperty(this, "handleItemInteract", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.isItemInteraction = s.detail.itemInteraction;
      }
    }), this.state = {
      isDragging: !1
    };
  }
  componentWillUnmount() {
    this.scrollComponent && (this.scrollComponent.removeEventListener("wheel", this.handleWheel), this.scrollComponent.removeEventListener("itemInteraction", this.handleItemInteract));
  }
  render() {
    const { width: i, height: s, children: u } = this.props, { isDragging: f } = this.state, v = {
      width: `${i}px`,
      height: `${s + 20}px`,
      //20px to push the scroll element down off screen...?
      cursor: f ? "move" : "default",
      position: "relative"
    };
    return H("div", { ref: this.refHandler, "data-testid": "scroll-element", className: "rct-scroll", style: v, onMouseDown: this.handleMouseDown, onMouseMove: this.handleMouseMove, onMouseUp: this.handleMouseUp, onMouseLeave: this.handleMouseLeave, onTouchStart: this.handleTouchStart, onTouchMove: this.handleTouchMove, onTouchEnd: this.handleTouchEnd, onScroll: this.handleScroll, children: u });
  }
}
const xd = {
  subscribeToMouseOver: () => (console.warn('"subscribeToMouseOver" default func is being used'), () => {
  })
}, { Consumer: Od, Provider: _d } = se.createContext(xd), Md = _d, Cd = Od, Ed = {
  markers: [],
  subscribeMarker: () => (console.warn("default subscribe marker used"), {
    unsubscribe: $t,
    getMarker: $t
  }),
  updateMarker: () => (console.warn("default subscribe marker used"), $t)
}, { Consumer: Id, Provider: Pd } = se.createContext(Ed);
let fi = 0;
const Dd = () => (fi += 1, fi + 1);
class $d extends se.Component {
  constructor(i) {
    super(i), Object.defineProperty(this, "handleSubscribeToMarker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => (s = {
        ...s,
        // REVIEW: in the event that we accept id to be passed to the Marker components, this line would override those
        id: Dd()
      }, this.setState((u) => ({
        markers: [...u.markers, s]
      })), {
        unsubscribe: () => {
          this.setState((u) => ({
            markers: u.markers.filter((f) => f.id !== s.id)
          }));
        },
        getMarker: () => s
      })
    }), Object.defineProperty(this, "handleUpdateMarker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        const u = this.state.markers.findIndex((f) => f.id === s.id);
        u < 0 || this.setState((f) => ({
          markers: [
            ...f.markers.slice(0, u),
            s,
            ...f.markers.slice(u + 1)
          ]
        }));
      }
    }), this.state = {
      markers: [],
      subscribeMarker: this.handleSubscribeToMarker,
      updateMarker: this.handleUpdateMarker
    };
  }
  render() {
    return H(Pd, { value: this.state, children: this.props.children });
  }
}
const Xt = Id;
var We;
(function(a) {
  a.Today = "Today", a.Custom = "Custom", a.Cursor = "Cursor";
})(We || (We = {}));
const kd = {
  position: "absolute",
  top: 0,
  bottom: 0,
  width: "2px",
  backgroundColor: "black",
  // by default, pointer events (specifically click) will
  // "pass through".  This is added so that CursorMarker
  // will not get in the way of canvas click
  pointerEvents: "none"
}, Yr = (a) => ({
  ...kd,
  left: a
}), Gr = (a) => function({ styles: s }) {
  return H("div", { style: s, "data-testid": a });
}, zd = Gr("default-today-line");
let Xi = class extends se.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        date: Date.now()
      }
    }), Object.defineProperty(this, "intervalToken", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  componentDidMount() {
    this.intervalToken = this.createIntervalUpdater(this.props.interval);
  }
  componentDidUpdate(i) {
    i.interval !== this.props.interval && (clearInterval(this.intervalToken), this.intervalToken = this.createIntervalUpdater(this.props.interval));
  }
  createIntervalUpdater(i) {
    return setInterval(() => {
      this.setState({
        date: Date.now()
        // FIXME: use date utils pass in as props
      });
    }, i);
  }
  componentWillUnmount() {
    clearInterval(this.intervalToken);
  }
  render() {
    const { date: i } = this.state, s = this.props.getLeftOffsetFromDate(i), u = Yr(s);
    return this.props.renderer({ styles: u, date: i });
  }
};
Object.defineProperty(Xi, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    renderer: zd
  }
});
const Rd = Gr("default-customer-marker-id");
let Bi = class extends se.Component {
  render() {
    const { date: i } = this.props, s = this.props.getLeftOffsetFromDate(i), u = Yr(s);
    return this.props.renderer({ styles: u, date: i });
  }
};
Object.defineProperty(Bi, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    renderer: Rd
  }
});
const jd = Gr("default-cursor-marker");
let Vi = class extends se.Component {
  constructor(i) {
    super(i), Object.defineProperty(this, "handleCanvasMouseOver", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ({ leftOffset: s, date: u, isCursorOverCanvas: f }) => {
        this.setState({
          leftOffset: s,
          date: u,
          isShowingCursor: f
        });
      }
    }), Object.defineProperty(this, "unsubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.state = {
      leftOffset: 0,
      date: 0,
      isShowingCursor: !1
    };
  }
  componentDidMount() {
    this.unsubscribe = this.props.subscribeToCanvasMouseOver(this.handleCanvasMouseOver);
  }
  componentWillUnmount() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  render() {
    const { isShowingCursor: i, leftOffset: s, date: u } = this.state;
    if (!i)
      return null;
    const f = Yr(s);
    return this.props.renderer ? this.props.renderer({ styles: f, date: u }) : null;
  }
};
Object.defineProperty(Vi, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    renderer: jd
  }
});
const qi = (a) => H(Cd, { children: ({ subscribeToMouseOver: i }) => H(Vi, { subscribeToCanvasMouseOver: i, ...a }) });
qi.displayName = "CursorMarkerWrapper";
const Ad = () => H(Kt, { children: ({ getLeftOffsetFromDate: a, getTimelineState: i }) => H(Xt, { children: ({ markers: s }) => {
  const u = i();
  return s.map((f) => {
    switch (f.type) {
      case We.Today:
        return (/* @__PURE__ */ new Date()).valueOf() >= u.canvasTimeStart && (/* @__PURE__ */ new Date()).valueOf() <= u.canvasTimeEnd ? H(Xi, { getLeftOffsetFromDate: a, renderer: f.renderer, interval: f.interval }, f.id) : null;
      case We.Custom:
        return f.date >= u.canvasTimeStart && f.date <= u.canvasTimeEnd ? H(Bi, { renderer: f.renderer, date: f.date, getLeftOffsetFromDate: a }, f.id) : null;
      case We.Cursor:
        return H(qi, { renderer: f.renderer, getLeftOffsetFromDate: a }, f.id);
      default:
        return null;
    }
  });
} }) }), Ld = {
  position: "absolute",
  left: 0,
  right: 0,
  top: 0,
  bottom: 0
};
class Hd extends se.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "handleMouseMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        var s;
        if (this.subscription !== null) {
          const { pageX: u } = i, { left: f } = ((s = this.containerEl.current) == null ? void 0 : s.getBoundingClientRect()) ?? {
            left: 0
          }, v = u - f, m = this.props.getDateFromLeftOffsetPosition(v);
          this.subscription({
            leftOffset: v,
            date: m,
            isCursorOverCanvas: !0
          });
        }
      }
    }), Object.defineProperty(this, "handleMouseLeave", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.subscription !== null && this.subscription({ leftOffset: 0, date: 0, isCursorOverCanvas: !1 });
      }
    }), Object.defineProperty(this, "handleMouseMoveSubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => (this.subscription = i, () => {
        this.subscription = null;
      })
    }), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        subscribeToMouseOver: this.handleMouseMoveSubscribe
      }
    }), Object.defineProperty(this, "containerEl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: se.createRef()
    }), Object.defineProperty(this, "subscription", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  render() {
    return H(Md, { value: this.state, children: Xe("div", { style: Ld, onMouseMove: this.handleMouseMove, onMouseLeave: this.handleMouseLeave, ref: this.containerEl, children: [H(Ad, {}), this.props.children] }) });
  }
}
const Fd = (a) => H(Kt, { children: ({ getDateFromLeftOffsetPosition: i }) => H(Hd, { getDateFromLeftOffsetPosition: i, ...a }) });
function Wd(a) {
  a._resizeEventListener = () => a.resize(), window.addEventListener("resize", a._resizeEventListener);
}
function Ud(a) {
  window.removeEventListener("resize", a._resizeEventListener);
}
const vi = { addListener: Wd, removeListener: Ud }, Nd = {
  groupIdKey: "id",
  groupTitleKey: "title",
  groupRightTitleKey: "rightTitle",
  groupLabelKey: "title",
  itemIdKey: "id",
  itemTitleKey: "title",
  itemDivTitleKey: "title",
  itemGroupKey: "group",
  itemTimeStartKey: "start_time",
  itemTimeEndKey: "end_time"
}, Yd = {
  second: 1,
  minute: 1,
  hour: 1,
  day: 1,
  month: 1,
  year: 1
}, Gd = {
  year: {
    long: "YYYY",
    mediumLong: "YYYY",
    medium: "YYYY",
    short: "YY"
  },
  month: {
    long: "MMMM YYYY",
    mediumLong: "MMMM",
    medium: "MMMM",
    short: "MM/YY"
  },
  week: {
    long: "w",
    mediumLong: "w",
    medium: "w",
    short: "w"
  },
  day: {
    long: "dddd, LL",
    mediumLong: "dddd, LL",
    medium: "dd D",
    short: "D"
  },
  hour: {
    long: "dddd, LL, HH:00",
    mediumLong: "L, HH:00",
    medium: "HH:00",
    short: "HH"
  },
  minute: {
    long: "HH:mm",
    mediumLong: "HH:mm",
    medium: "HH:mm",
    short: "mm"
  },
  second: {
    long: "mm:ss",
    mediumLong: "mm:ss",
    medium: "mm:ss",
    short: "ss"
  }
}, Kd = {
  registerScroll: () => (console.warn("default registerScroll header used"), $t),
  rightSidebarWidth: 0,
  leftSidebarWidth: 150,
  timeSteps: {}
}, Zi = se.createContext(Kd);
class Xd extends se.Component {
  render() {
    const i = {
      rightSidebarWidth: this.props.rightSidebarWidth,
      leftSidebarWidth: this.props.leftSidebarWidth,
      timeSteps: this.props.timeSteps,
      registerScroll: this.props.registerScroll
    };
    return H(Zi.Provider, { value: i, children: this.props.children });
  }
}
const Bd = Zi, Kr = () => Ti(Bd);
var Ji = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(a) {
  (function() {
    var i = {}.hasOwnProperty;
    function s() {
      for (var v = "", m = 0; m < arguments.length; m++) {
        var y = arguments[m];
        y && (v = f(v, u(y)));
      }
      return v;
    }
    function u(v) {
      if (typeof v == "string" || typeof v == "number")
        return v;
      if (typeof v != "object")
        return "";
      if (Array.isArray(v))
        return s.apply(null, v);
      if (v.toString !== Object.prototype.toString && !v.toString.toString().includes("[native code]"))
        return v.toString();
      var m = "";
      for (var y in v)
        i.call(v, y) && v[y] && (m = f(m, y));
      return m;
    }
    function f(v, m) {
      return m ? v ? v + " " + m : v + m : v;
    }
    a.exports ? (s.default = s, a.exports = s) : window.classNames = s;
  })();
})(Ji);
var Vd = Ji.exports;
const gi = /* @__PURE__ */ Ze(Vd), qd = "left", Qi = "right";
class Zd extends bs {
  constructor() {
    super(...arguments), Object.defineProperty(this, "getRootProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i = {}) => {
        const { style: s } = i, u = this.props.variant === Qi ? this.props.rightSidebarWidth : this.props.leftSidebarWidth;
        return {
          style: {
            ...s,
            width: u
          }
        };
      }
    }), Object.defineProperty(this, "getStateAndHelpers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => ({
        getRootProps: this.getRootProps,
        data: this.props.headerData
      })
    });
  }
  render() {
    const i = this.getStateAndHelpers(), s = this.props.children;
    return H(s, { ...i });
  }
}
const Jd = ({ getRootProps: a }) => H("div", { "data-testid": "sidebarHeader", ...a() }), zt = (a) => {
  const { children: i, variant: s = qd, headerData: u } = a, { leftSidebarWidth: f, rightSidebarWidth: v } = Kr();
  return H(Zd, { leftSidebarWidth: f, rightSidebarWidth: v, variant: s, headerData: u, children: i || Jd });
};
zt.secretKey = "SidebarHeader";
class Qd extends se.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "getRootStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => ({
        ...this.props.style,
        display: "flex",
        width: "100%"
      })
    }), Object.defineProperty(this, "getCalendarHeaderStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { leftSidebarWidth: i, rightSidebarWidth: s, calendarHeaderStyle: u } = this.props;
        return {
          ...u,
          overflow: "hidden",
          width: `calc(100% - ${i + s}px)`
        };
      }
    }), Object.defineProperty(this, "isSidebarHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => i.type === void 0 ? !1 : i.type.secretKey === zt.secretKey
    });
  }
  render() {
    let i, s;
    const u = [], f = Array.isArray(this.props.children) ? this.props.children.filter((v) => v) : [this.props.children];
    return se.Children.map(f, (v) => {
      var m;
      this.isSidebarHeader(v) ? ((m = v == null ? void 0 : v.props) == null ? void 0 : m.variant) === Qi ? i = v : s = v : u.push(v);
    }), s || (s = H(zt, {})), !i && this.props.rightSidebarWidth && (i = H(zt, { variant: "right" })), Xe("div", { "data-testid": "headerRootDiv", style: this.getRootStyle(), className: gi("rct-header-root", this.props.className), children: [s, H("div", { ref: this.props.registerScroll, style: this.getCalendarHeaderStyle(), className: gi("rct-calendar-header", this.props.calendarHeaderClassName), "data-testid": "headerContainer", children: u }), i] });
  }
}
const $r = ({ children: a, style: i, className: s, calendarHeaderStyle: u, calendarHeaderClassName: f }) => {
  const { leftSidebarWidth: v, rightSidebarWidth: m, registerScroll: y } = Kr();
  return H(Qd, { leftSidebarWidth: v, rightSidebarWidth: m, registerScroll: y, style: i, className: s, calendarHeaderStyle: u, calendarHeaderClassName: f, children: a });
};
$r.secretKey = "TimelineHeaders";
class eo extends se.Component {
  constructor(i) {
    super(i), Object.defineProperty(this, "getHeaderIntervals", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ({ canvasTimeStart: x, canvasTimeEnd: O, unit: k, timeSteps: P, getLeftOffsetFromDate: T }) => {
        const C = [];
        return Ar(x, O, k, P, (M, _) => {
          const z = T(M.valueOf()), Y = T(_.valueOf()) - z;
          C.push({
            startTime: M,
            endTime: _,
            labelWidth: Y,
            left: z
          });
        }), C;
      }
    }), Object.defineProperty(this, "getRootProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (x = {}) => {
        const { style: O } = x;
        return {
          style: Object.assign({}, O || {}, {
            position: "relative",
            width: this.props.canvasWidth,
            height: this.props.height
          })
        };
      }
    }), Object.defineProperty(this, "getIntervalProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (x = {}) => {
        const { interval: O, style: k } = x;
        if (!O)
          throw new Error("you should provide interval to the prop getter");
        const { startTime: P, labelWidth: T, left: C } = O;
        return {
          style: {
            ...k,
            left: C,
            width: T,
            position: "absolute"
          },
          key: `label-${P.valueOf()}`
        };
      }
    }), Object.defineProperty(this, "getStateAndHelpers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const {
          /*canvasTimeStart,
          canvasTimeEnd,
          timelineWidth,
          visibleTimeStart,
          visibleTimeEnd,*/
          unit: x,
          showPeriod: O,
          headerData: k
        } = this.props;
        return {
          /*timelineContext: {
            timelineWidth,
            visibleTimeStart,
            visibleTimeEnd,
            canvasTimeStart,
            canvasTimeEnd,
          },*/
          headerContext: {
            unit: x,
            intervals: this.state.intervals
          },
          getRootProps: this.getRootProps,
          getIntervalProps: this.getIntervalProps,
          showPeriod: O,
          data: k
        };
      }
    });
    const { canvasTimeStart: s, canvasTimeEnd: u, unit: f, timeSteps: v, getLeftOffsetFromDate: m } = i, y = this.getHeaderIntervals({
      canvasTimeStart: s,
      canvasTimeEnd: u,
      unit: f,
      timeSteps: v,
      getLeftOffsetFromDate: m
    });
    this.state = {
      intervals: y
    };
  }
  /*shouldComponentUpdate(nextProps: CustomHeaderProps<Data>) {
    if (
      nextProps.canvasTimeStart !== this.props.canvasTimeStart ||
      nextProps.canvasTimeEnd !== this.props.canvasTimeEnd ||
      nextProps.canvasWidth !== this.props.canvasWidth ||
      nextProps.unit !== this.props.unit ||
      nextProps.timeSteps !== this.props.timeSteps ||
      nextProps.showPeriod !== this.props.showPeriod ||
      nextProps.children !== this.props.children ||
      nextProps.headerData !== this.props.headerData
    ) {
      return true
    }
    return false
  }*/
  componentDidUpdate(i) {
    if (!_r(i, this.props)) {
      const { canvasTimeStart: s, canvasTimeEnd: u, unit: f, timeSteps: v, getLeftOffsetFromDate: m } = this.props, y = this.getHeaderIntervals({
        canvasTimeStart: s,
        canvasTimeEnd: u,
        unit: f,
        timeSteps: v,
        getLeftOffsetFromDate: m
      });
      this.setState({ intervals: y });
    }
  }
  render() {
    const i = this.getStateAndHelpers(), s = this.props.children;
    return H(s, { ...i });
  }
}
Object.defineProperty(eo, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    height: 30
  }
});
function ef({ children: a, unit: i, headerData: s, height: u }) {
  const { getTimelineState: f, showPeriod: v, getLeftOffsetFromDate: m } = dd(), y = f(), { timeSteps: x } = Kr();
  return H(eo, { children: a, timeSteps: x, showPeriod: v, unit: i || y.timelineUnit, ...y, headerData: s, getLeftOffsetFromDate: m, height: u });
}
var mi = Number.isNaN || function(i) {
  return typeof i == "number" && i !== i;
};
function tf(a, i) {
  return !!(a === i || mi(a) && mi(i));
}
function rf(a, i) {
  if (a.length !== i.length)
    return !1;
  for (var s = 0; s < a.length; s++)
    if (!tf(a[s], i[s]))
      return !1;
  return !0;
}
function bi(a, i) {
  i === void 0 && (i = rf);
  var s = null;
  function u() {
    for (var f = [], v = 0; v < arguments.length; v++)
      f[v] = arguments[v];
    if (s && s.lastThis === this && i(f, s.lastArgs))
      return s.lastResult;
    var m = a.apply(this, f);
    return s = {
      lastResult: m,
      lastArgs: f,
      lastThis: this
    }, m;
  }
  return u.clear = function() {
    s = null;
  }, u;
}
class nf extends se.PureComponent {
  constructor() {
    super(...arguments), Object.defineProperty(this, "onIntervalClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { primaryHeader: i, interval: s, unit: u, showPeriod: f } = this.props;
        if (i) {
          const v = Lr(u), m = s.startTime.clone().startOf(v), y = s.startTime.clone().endOf(v);
          f(m, y);
        } else
          f(s.startTime, s.endTime);
      }
    }), Object.defineProperty(this, "getIntervalProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i = {}) => ({
        ...this.props.getIntervalProps({
          interval: this.props.interval,
          ...i
        }),
        onClick: Ke(this.onIntervalClick, i.onClick)
      })
    });
  }
  render() {
    const { intervalText: i, interval: s, intervalRenderer: u, headerData: f } = this.props, v = u;
    if (v)
      return H(v, { getIntervalProps: this.getIntervalProps, intervalContext: {
        interval: s,
        intervalText: i
      }, data: f });
    const { key: m, ...y } = this.getIntervalProps();
    return ys(
      "div",
      { "data-testid": "dateHeaderInterval", ...y, key: m, className: `rct-dateHeader ${this.props.primaryHeader ? "rct-dateHeader-primary" : ""}` },
      H("span", { children: i })
    );
  }
}
function of({ headerContext: { intervals: a, unit: i }, getRootProps: s, getIntervalProps: u, showPeriod: f, data: { style: v, intervalRenderer: m, className: y, getLabelFormat: x, unitProp: O, headerData: k } }) {
  return H("div", { "data-testid": "dateHeader", className: y, ...s({ style: v }), children: a.map((P) => {
    const T = x([P.startTime, P.endTime], i, P.labelWidth);
    return H(nf, { unit: i, interval: P, showPeriod: f, intervalText: T, primaryHeader: O === "primaryHeader", getIntervalProps: u, intervalRenderer: m, headerData: k }, `label-${P.startTime.valueOf()}`);
  }) });
}
class sf extends se.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "getHeaderUnit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => this.props.unit === "primaryHeader" ? Lr(this.props.timelineUnit) : this.props.unit ? this.props.unit : this.props.timelineUnit
    }), Object.defineProperty(this, "getRootStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: bi((i) => ({
        height: 30,
        ...i
      }))
    }), Object.defineProperty(this, "getLabelFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i, s, u) => {
        const { labelFormat: f } = this.props;
        if (typeof f == "string")
          return i[0].format(f);
        if (typeof f == "function")
          return f(i, s, u);
        throw new Error("labelFormat should be function or string");
      }
    }), Object.defineProperty(this, "getHeaderData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: bi((i, s, u, f, v, m) => ({
        intervalRenderer: i,
        style: s,
        className: u,
        getLabelFormat: f,
        unitProp: v,
        headerData: m
      }))
    });
  }
  render() {
    const i = this.getHeaderUnit(), { height: s } = this.props;
    return H(ef, { children: of, unit: i, height: s, headerData: this.getHeaderData(this.props.intervalRenderer, this.getRootStyle(this.props.style), this.props.className, this.getLabelFormat, this.props.unit, this.props.headerData) });
  }
}
function yi({ labelFormat: a, unit: i, style: s, className: u, intervalRenderer: f, headerData: v, height: m }) {
  return H(Kt, { children: ({ getTimelineState: y }) => {
    const x = y();
    return H(sf, { timelineUnit: x.timelineUnit, unit: i, labelFormat: a || af, style: s, className: u, intervalRenderer: f, headerData: v, height: m });
  } });
}
function af([a], i, s, u = Gd) {
  let f;
  return s >= 150 ? f = u[i].long : s >= 100 ? f = u[i].mediumLong : s >= 50 ? f = u[i].medium : f = u[i].short, a.format(f);
}
var to = { exports: {} };
(function(a, i) {
  (function(s, u) {
    a.exports = u();
  })(Fe, function() {
    var s = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
    return function(u, f, v) {
      var m = f.prototype, y = m.format;
      v.en.formats = s, m.format = function(x) {
        x === void 0 && (x = "YYYY-MM-DDTHH:mm:ssZ");
        var O = this.$locale().formats, k = function(P, T) {
          return P.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(C, M, _) {
            var z = _ && _.toUpperCase();
            return M || T[_] || s[_] || T[z].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(X, Y, ee) {
              return Y || ee.slice(1);
            });
          });
        }(x, O === void 0 ? {} : O);
        return y.call(this, k);
      };
    };
  });
})(to);
var lf = to.exports;
const cf = /* @__PURE__ */ Ze(lf);
De.extend(cf);
class ro extends xe {
  constructor(i) {
    super(i), Object.defineProperty(this, "getTimelineContext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { width: T, visibleTimeStart: C, visibleTimeEnd: M, canvasTimeStart: _, canvasTimeEnd: z } = this.state, X = M - C, Y = He(T, this.props.buffer), ee = kt(X, T, this.props.timeSteps);
        return {
          canvasWidth: Y,
          timelineUnit: ee,
          timelineWidth: T,
          visibleTimeStart: C,
          visibleTimeEnd: M,
          canvasTimeStart: _,
          canvasTimeEnd: z
        };
      }
    }), Object.defineProperty(this, "getTimelineUnit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { width: T, visibleTimeStart: C, visibleTimeEnd: M } = this.state, { timeSteps: _ } = this.props, z = M - C;
        return kt(z, T, _);
      }
    }), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "scrollComponent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "scrollHeaderRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "resize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T = this.props) => {
        var ne;
        const { width: C } = ((ne = this.container.current) == null ? void 0 : ne.getBoundingClientRect()) ?? { width: 0 }, M = C - T.sidebarWidth - T.rightSidebarWidth, _ = He(M, T.buffer), { dimensionItems: z, height: X, groupHeights: Y, groupTops: ee } = qe(T.items, T.groups, _, this.state.canvasTimeStart, this.state.canvasTimeEnd, T.keys, T.lineHeight, T.itemHeightRatio, T.stackItems, this.state.draggingItem, this.state.resizingItem, this.state.dragTime, this.state.resizingEdge, this.state.resizeTime, this.state.newGroupOrder);
        this.setState({
          width: M,
          dimensionItems: z,
          height: X,
          groupHeights: Y,
          groupTops: ee
        });
        const te = M * ((T.buffer - 1) / 2);
        this.scrollComponent && (this.scrollComponent.scrollLeft = te), this.scrollHeaderRef && (this.scrollHeaderRef.scrollLeft = te);
      }
    }), Object.defineProperty(this, "onScroll", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => {
        var X, Y;
        const C = this.state.width, M = this.state.canvasTimeStart, _ = this.state.visibleTimeEnd - this.state.visibleTimeStart, z = M + _ * T / C;
        (this.state.visibleTimeStart !== z || this.state.visibleTimeEnd !== z + _) && ((Y = (X = this.props).onTimeChange) == null || Y.call(X, z, z + _, this.updateScrollCanvas, this.getTimelineUnit()));
      }
    }), Object.defineProperty(this, "updateScrollCanvas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, C, M = !1, _ = this.props.items, z = this.props.groups) => {
        this.setState(Ir(T, C, M, _, z, this.props, this.state));
      }
    }), Object.defineProperty(this, "handleWheelZoom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, C, M) => {
        this.changeZoom(1 + T * M / 500, C / this.state.width);
      }
    }), Object.defineProperty(this, "changeZoom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, C = 0.5) => {
        const { minZoom: M, maxZoom: _ } = this.props, z = this.state.visibleTimeEnd - this.state.visibleTimeStart, X = Math.min(Math.max(Math.round(z * T), M), _), Y = Math.round(this.state.visibleTimeStart + (z - X) * C);
        this.props.onTimeChange && this.props.onTimeChange(Y, Y + X, this.updateScrollCanvas, this.getTimelineUnit());
      }
    }), Object.defineProperty(this, "showPeriod", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, C) => {
        var X, Y;
        const M = T.valueOf(), z = C.valueOf() - M;
        z < this.props.minZoom || (Y = (X = this.props).onTimeChange) == null || Y.call(X, M, M + z, this.updateScrollCanvas, this.getTimelineUnit());
      }
    }), Object.defineProperty(this, "selectItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, C, M) => {
        if (this.isItemSelected(T) || this.props.itemTouchSendsClick && C === "touch") {
          if (T && this.props.onItemClick) {
            const _ = this.timeFromItemEvent(M);
            this.props.onItemClick(T, M, _);
          }
        } else if (this.setState({ selectedItem: T }), T && this.props.onItemSelect) {
          const _ = this.timeFromItemEvent(M);
          this.props.onItemSelect(T, M, _);
        } else T === null && this.props.onItemDeselect && this.props.onItemDeselect(M);
      }
    }), Object.defineProperty(this, "doubleClickItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, C) => {
        if (this.props.onItemDoubleClick) {
          const M = this.timeFromItemEvent(C);
          this.props.onItemDoubleClick(T, C, M);
        }
      }
    }), Object.defineProperty(this, "contextMenuClickItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, C) => {
        if (this.props.onItemContextMenu) {
          const M = this.timeFromItemEvent(C);
          this.props.onItemContextMenu(T, C, M);
        }
      }
    }), Object.defineProperty(this, "getTimeFromRowClickEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => {
        const { dragSnap: C, buffer: M } = this.props, { width: _, canvasTimeStart: z, canvasTimeEnd: X } = this.state, { offsetX: Y } = T.nativeEvent;
        let ee = jr(z, X, He(_, M), Y);
        return ee = Math.floor(ee / C) * C, ee;
      }
    }), Object.defineProperty(this, "timeFromItemEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => {
        const { width: C, visibleTimeStart: M, visibleTimeEnd: _ } = this.state, z = this.props.dragSnap, X = this.scrollComponent, { left: Y } = X.getBoundingClientRect(), te = (T.clientX - Y) / C, ne = _ - M, ue = te * ne;
        let S = Math.round(M + ue);
        return S = Math.floor(S / z) * z, S;
      }
    }), Object.defineProperty(this, "dragItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, C, M) => {
        const _ = this.props.groups[M], z = this.props.keys;
        this.setState({
          draggingItem: T,
          dragTime: C,
          newGroupOrder: M,
          dragGroupTitle: _ ? J(_, z.groupLabelKey) : ""
        }), this.updatingItem({
          eventType: "move",
          itemId: T,
          time: C,
          newGroupOrder: M
        });
      }
    }), Object.defineProperty(this, "dropItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, C, M) => {
        this.setState({ draggingItem: null, dragTime: null, dragGroupTitle: null }), this.props.onItemMove && this.props.onItemMove(T, C, M);
      }
    }), Object.defineProperty(this, "resizingItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, C, M) => {
        this.setState({
          resizingItem: T,
          resizingEdge: M,
          resizeTime: C
        }), this.updatingItem({
          eventType: "resize",
          itemId: T,
          time: C,
          edge: M || void 0
        });
      }
    }), Object.defineProperty(this, "resizedItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, C, M, _) => {
        this.setState({ resizingItem: null, resizingEdge: null, resizeTime: null }), this.props.onItemResize && _ !== 0 && this.props.onItemResize(T, C, M);
      }
    }), Object.defineProperty(this, "updatingItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ({ eventType: T, itemId: C, time: M, edge: _, newGroupOrder: z }) => {
        this.props.onItemDrag && (T === "move" ? this.props.onItemDrag({
          eventType: T,
          itemId: C,
          time: M,
          newGroupOrder: z
        }) : this.props.onItemDrag({
          eventType: T,
          itemId: C,
          time: M,
          edge: _
        }));
      }
    }), Object.defineProperty(this, "handleRowClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, C) => {
        if (this.hasSelectedItem() && this.selectItem(null, "click", T), this.props.onCanvasClick == null)
          return;
        const M = this.getTimeFromRowClickEvent(T), _ = J(this.props.groups[C], this.props.keys.groupIdKey);
        this.props.onCanvasClick(_, M, T);
      }
    }), Object.defineProperty(this, "handleRowDoubleClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, C) => {
        if (this.props.onCanvasDoubleClick == null)
          return;
        const M = this.getTimeFromRowClickEvent(T), _ = J(this.props.groups[C], this.props.keys.groupIdKey);
        this.props.onCanvasDoubleClick(_, M, T);
      }
    }), Object.defineProperty(this, "handleScrollContextMenu", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, C) => {
        if (this.props.onCanvasContextMenu == null)
          return;
        const M = this.getTimeFromRowClickEvent(T), _ = J(this.props.groups[C], this.props.keys.groupIdKey);
        this.props.onCanvasContextMenu && (T.preventDefault(), this.props.onCanvasContextMenu(_, M, T));
      }
    }), Object.defineProperty(this, "handleHeaderRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => {
        this.scrollHeaderRef = T, this.props.headerRef && this.props.headerRef(T);
      }
    }), Object.defineProperty(this, "isTimelineHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => T.type === void 0 ? !1 : T.type.secretKey === $r.secretKey
    }), Object.defineProperty(this, "renderHeaders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        if (this.props.children) {
          let T;
          if (se.Children.map(this.props.children, (C) => {
            this.isTimelineHeader(C) && (T = C);
          }), T)
            return T;
        }
        return Xe($r, { children: [H(yi, { unit: "primaryHeader" }), H(yi, {})] });
      }
    }), Object.defineProperty(this, "getScrollElementRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => {
        this.props.scrollRef && this.props.scrollRef(T), this.scrollComponent = T;
      }
    }), Object.defineProperty(this, "container", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: se.createRef()
    }), this.getSelected = this.getSelected.bind(this), this.hasSelectedItem = this.hasSelectedItem.bind(this), this.isItemSelected = this.isItemSelected.bind(this);
    let s = null, u = null;
    if (this.props.defaultTimeStart && this.props.defaultTimeEnd)
      s = this.props.defaultTimeStart, u = this.props.defaultTimeEnd;
    else if (this.props.visibleTimeStart && this.props.visibleTimeEnd)
      s = this.props.visibleTimeStart, u = this.props.visibleTimeEnd;
    else
      throw new Error('You must provide either "defaultTimeStart" and "defaultTimeEnd" or "visibleTimeStart" and "visibleTimeEnd" to initialize the Timeline');
    const [f, v] = Wr(s, u, i.buffer), m = {
      width: 1e3,
      visibleTimeStart: s,
      visibleTimeEnd: u,
      canvasTimeStart: f,
      canvasTimeEnd: v,
      selectedItem: null,
      dragTime: null,
      dragGroupTitle: null,
      resizeTime: null,
      resizingItem: null,
      resizingEdge: null,
      newGroupOrder: 0
      //CHECK
    }, y = He(m.width, i.buffer), { dimensionItems: x, height: O, groupHeights: k, groupTops: P } = qe(i.items, i.groups, y, m.canvasTimeStart, m.canvasTimeEnd, i.keys, i.lineHeight, i.itemHeightRatio, i.stackItems, m.draggingItem, m.resizingItem, m.dragTime, m.resizingEdge, m.resizeTime, m.newGroupOrder);
    m.dimensionItems = x, m.height = O, m.groupHeights = k, m.groupTops = P, this.state = m;
  }
  componentDidMount() {
    this.resize(this.props), this.props.resizeDetector && this.props.resizeDetector.addListener && this.props.resizeDetector.addListener(this), vi.addListener(this);
  }
  componentWillUnmount() {
    this.props.resizeDetector && this.props.resizeDetector.addListener && this.props.resizeDetector.removeListener(this), vi.removeListener(this);
  }
  static getDerivedStateFromProps(i, s) {
    const { visibleTimeStart: u, visibleTimeEnd: f, items: v, groups: m } = i, y = { items: v, groups: m }, x = v !== s.items || m !== s.groups;
    if (u && f)
      Object.assign(y, Ir(u, f, x, v, m, i, s));
    else if (x) {
      const O = He(s.width, i.buffer);
      Object.assign(y, qe(v, m, O, s.canvasTimeStart, s.canvasTimeEnd, i.keys, i.lineHeight, i.itemHeightRatio, i.stackItems, s.draggingItem, s.resizingItem, s.dragTime, s.resizingEdge, s.resizeTime, s.newGroupOrder));
    }
    return y;
  }
  componentDidUpdate(i, s) {
    const u = this.state.visibleTimeEnd - this.state.visibleTimeStart, f = s.visibleTimeEnd - s.visibleTimeStart;
    this.props.onZoom && u !== f && this.props.onZoom(this.getTimelineContext(), this.getTimelineUnit()), this.props.onBoundsChange && this.state.canvasTimeStart !== s.canvasTimeStart && this.props.onBoundsChange(this.state.canvasTimeStart, this.state.canvasTimeStart + u * 3);
    const v = Math.round(this.state.width * (this.state.visibleTimeStart - this.state.canvasTimeStart) / u);
    Math.round(s.width * (s.visibleTimeStart - s.canvasTimeStart) / f) !== v && (this.scrollComponent.scrollLeft = v, this.scrollHeaderRef.scrollLeft = v);
  }
  columns(i, s, u, f, v, m) {
    var y;
    return H(bd, { canvasTimeStart: i, canvasTimeEnd: s, canvasWidth: u, lineCount: ((y = this.props.groups) == null ? void 0 : y.length) || 0, minUnit: f, timeSteps: v, height: m, verticalLineClassNamesForTime: this.props.verticalLineClassNamesForTime });
  }
  rows(i, s, u) {
    var f;
    return H(wd, { groups: u, canvasWidth: i, lineCount: ((f = this.props.groups) == null ? void 0 : f.length) || 0, groupHeights: s, clickTolerance: this.props.clickTolerance, onRowClick: this.handleRowClick, onRowDoubleClick: this.handleRowDoubleClick, horizontalLineClassNamesForGroup: this.props.horizontalLineClassNamesForGroup, onRowContextClick: this.handleScrollContextMenu });
  }
  items({ canvasTimeStart: i, canvasTimeEnd: s, canvasWidth: u, dimensionItems: f, groupTops: v }) {
    return H(gd, { canvasTimeStart: i, canvasTimeEnd: s, canvasWidth: u, dimensionItems: f, groupTops: v, items: this.props.items, groups: this.props.groups, keys: this.props.keys, selectedItem: this.state.selectedItem || void 0, dragSnap: this.props.dragSnap, minResizeWidth: this.props.minResizeWidth, canChangeGroup: this.props.canChangeGroup, canMove: this.props.canMove, canResize: this.props.canResize, useResizeHandle: this.props.useResizeHandle, canSelect: this.props.canSelect, moveResizeValidator: this.props.moveResizeValidator, itemSelect: this.selectItem, itemDrag: this.dragItem, itemDrop: this.dropItem, onItemDoubleClick: this.doubleClickItem, onItemContextMenu: this.props.onItemContextMenu ? this.contextMenuClickItem : void 0, itemResizing: this.resizingItem, itemResized: this.resizedItem, itemRenderer: this.props.itemRenderer, selected: this.props.selected, scrollRef: this.scrollComponent });
  }
  sidebar(i, s) {
    const { sidebarWidth: u } = this.props;
    return u && H(di, { groups: this.props.groups, groupRenderer: this.props.groupRenderer, keys: this.props.keys, width: u, groupHeights: s, height: i });
  }
  rightSidebar(i, s) {
    const { rightSidebarWidth: u } = this.props;
    return u && H(di, { groups: this.props.groups, keys: this.props.keys, groupRenderer: this.props.groupRenderer, isRightSidebar: !0, width: u, groupHeights: s, height: i });
  }
  childrenWithProps(i, s, u, f, v, m, y, x, O, k, P) {
    if (!this.props.children)
      return null;
    const T = Array.isArray(this.props.children) ? this.props.children.filter((M) => M) : [this.props.children], C = {
      canvasTimeStart: i,
      canvasTimeEnd: s,
      canvasWidth: u,
      visibleTimeStart: x,
      visibleTimeEnd: O,
      dimensionItems: f,
      items: this.props.items,
      groups: this.props.groups,
      keys: this.props.keys,
      groupHeights: v,
      groupTops: m,
      selected: this.getSelected(),
      height: y,
      minUnit: k,
      timeSteps: P
    };
    return se.Children.map(T, (M) => this.isTimelineHeader(M) ? null : se.cloneElement(M, C));
  }
  getSelected() {
    return this.state.selectedItem && !this.props.selected ? [this.state.selectedItem] : this.props.selected || [];
  }
  hasSelectedItem() {
    return Array.isArray(this.props.selected) ? this.props.selected.length > 0 : !!this.state.selectedItem;
  }
  isItemSelected(i) {
    return this.getSelected().some((u) => u === i);
  }
  render() {
    const { items: i, groups: s, sidebarWidth: u, rightSidebarWidth: f, timeSteps: v, traditionalZoom: m, buffer: y } = this.props, { draggingItem: x, resizingItem: O, width: k, visibleTimeStart: P, visibleTimeEnd: T, canvasTimeStart: C, canvasTimeEnd: M } = this.state;
    let { dimensionItems: _, height: z, groupHeights: X, groupTops: Y } = this.state;
    const ee = T - P, te = He(k, y), ne = kt(ee, k, v);
    if (!!x || !!O) {
      const be = qe(i, s, te, this.state.canvasTimeStart, this.state.canvasTimeEnd, this.props.keys, this.props.lineHeight, this.props.itemHeightRatio, this.props.stackItems, this.state.draggingItem, this.state.resizingItem, this.state.dragTime, this.state.resizingEdge, this.state.resizeTime, this.state.newGroupOrder);
      _ = be.dimensionItems, z = be.height, X = be.groupHeights, Y = be.groupTops;
    }
    const S = {
      height: `${z}px`
    };
    return H(hd, { visibleTimeStart: P, visibleTimeEnd: T, canvasTimeStart: C, canvasTimeEnd: M, canvasWidth: te, showPeriod: this.showPeriod, timelineUnit: ne, timelineWidth: this.state.width, children: H($d, { children: H(Xd, { registerScroll: this.handleHeaderRef, timeSteps: v, leftSidebarWidth: this.props.sidebarWidth, rightSidebarWidth: this.props.rightSidebarWidth, children: Xe("div", { style: this.props.style, ref: this.container, className: `react-calendar-timeline ${this.props.className}`, children: [this.renderHeaders(), Xe("div", { style: S, className: "rct-outer", children: [u > 0 ? this.sidebar(z, X) : null, H(Sd, { scrollRef: this.getScrollElementRef, width: k, height: z, onZoom: this.changeZoom, onWheelZoom: this.handleWheelZoom, traditionalZoom: !!m, onScroll: this.onScroll, children: Xe(Fd, { children: [this.columns(C, M, te, ne, v, z), this.rows(te, X, s), this.items({
      canvasTimeStart: C,
      canvasTimeEnd: M,
      canvasWidth: te,
      dimensionItems: _,
      groupTops: Y
    }), this.childrenWithProps(C, M, te, _, X, Y, z, P, T, ne, v)] }) }), f > 0 ? this.rightSidebar(z, X) : null] })] }) }) }) });
  }
}
Object.defineProperty(ro, "setDayjsLocale", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: De.locale
});
Object.defineProperty(ro, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    sidebarWidth: 150,
    rightSidebarWidth: 0,
    dragSnap: 1e3 * 60 * 15,
    // 15min
    minResizeWidth: 20,
    lineHeight: 30,
    itemHeightRatio: 0.65,
    buffer: 3,
    minZoom: 60 * 60 * 1e3,
    // 1 hour
    maxZoom: 5 * 365.24 * 86400 * 1e3,
    // 5 years
    clickTolerance: 3,
    // how many pixels can we drag for it to be still considered a click?
    canChangeGroup: !0,
    canMove: !0,
    canResize: "right",
    useResizeHandle: !1,
    canSelect: !0,
    stackItems: !1,
    traditionalZoom: !1,
    horizontalLineClassNamesForGroup: null,
    onItemMove: null,
    onItemResize: null,
    onItemClick: null,
    onItemSelect: null,
    onItemDeselect: null,
    onItemDrag: null,
    onCanvasClick: null,
    onItemDoubleClick: null,
    onItemContextMenu: null,
    onZoom: null,
    verticalLineClassNamesForTime: null,
    moveResizeValidator: null,
    dayBackground: null,
    defaultTimeStart: null,
    defaultTimeEnd: null,
    itemTouchSendsClick: !1,
    style: {},
    className: "",
    keys: Nd,
    timeSteps: Yd,
    headerRef: () => {
    },
    scrollRef: () => {
    },
    // if you pass in visibleTimeStart and visibleTimeEnd, you must also pass onTimeChange(visibleTimeStart, visibleTimeEnd),
    // which needs to update the props visibleTimeStart and visibleTimeEnd to the ones passed
    visibleTimeStart: null,
    visibleTimeEnd: null,
    onTimeChange: function(a, i, s) {
      s(a, i);
    },
    // called when the canvas area of the calendar changes
    onBoundsChange: null,
    children: null,
    selected: null
  }
});
const Sf = (a) => a.children || null;
class no extends se.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "unsubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "getMarker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  componentDidMount() {
    const { unsubscribe: i, getMarker: s } = this.props.subscribeMarker({
      type: We.Today,
      renderer: this.props.children,
      interval: this.props.interval
    });
    this.unsubscribe = i, this.getMarker = s;
  }
  componentWillUnmount() {
    this.unsubscribe != null && (this.unsubscribe(), this.unsubscribe = null);
  }
  componentDidUpdate(i) {
    if (i.interval !== this.props.interval && this.getMarker) {
      const s = this.getMarker();
      this.props.updateMarker({
        ...s,
        interval: this.props.interval
      });
    }
  }
  render() {
    return null;
  }
}
Object.defineProperty(no, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    interval: 1e3 * 10
    // default to ten seconds
  }
});
const uf = (a) => H(Xt, { children: ({ subscribeMarker: i, updateMarker: s }) => H(no, { subscribeMarker: i, updateMarker: s, ...a }) });
uf.displayName = "TodayMarkerWrapper";
class pf extends xe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "unsubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "getMarker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  componentDidUpdate(i) {
    if (i.date !== this.props.date && this.getMarker) {
      const s = this.getMarker();
      this.props.updateMarker({ ...s, date: this.props.date });
    }
  }
  componentDidMount() {
    const { unsubscribe: i, getMarker: s } = this.props.subscribeMarker({
      type: We.Custom,
      renderer: this.props.children,
      date: this.props.date
    });
    this.unsubscribe = i, this.getMarker = s;
  }
  componentWillUnmount() {
    this.unsubscribe != null && (this.unsubscribe(), this.unsubscribe = null);
  }
  render() {
    return null;
  }
}
const hf = (a) => H(Xt, { children: ({ subscribeMarker: i, updateMarker: s }) => H(pf, { subscribeMarker: i, updateMarker: s, ...a }) });
hf.displayName = "CustomMarkerWrapper";
class df extends xe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "unsubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  componentDidMount() {
    const { unsubscribe: i } = this.props.subscribeMarker({
      type: We.Cursor,
      renderer: this.props.children
    });
    this.unsubscribe = i;
  }
  componentWillUnmount() {
    this.unsubscribe != null && (this.unsubscribe(), this.unsubscribe = null);
  }
  render() {
    return null;
  }
}
const ff = (a) => H(Xt, { children: ({ subscribeMarker: i }) => H(df, { subscribeMarker: i, ...a }) });
ff.displayName = "CursorMarkerWrapper";
export {
  ff as CursorMarker,
  ef as CustomHeader,
  hf as CustomMarker,
  yi as DateHeader,
  Td as GroupRow,
  gd as RowItems,
  zt as SidebarHeader,
  ro as Timeline,
  $r as TimelineHeaders,
  Sf as TimelineMarkers,
  uf as TodayMarker,
  bf as calendarUtils,
  ro as default
};
//# sourceMappingURL=react-calendar-timeline.es.js.map
